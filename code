import androidx.compose.animation.core.DecayAnimationSpec
import androidx.compose.animation.core.LinearOutSlowInEasing
import androidx.compose.animation.core.SplineBasedDecay
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.rememberSplineBasedDecay
import androidx.compose.animation.core.animateDecay
import androidx.compose.animation.core.animateTo
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.consume
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.launch
import kotlin.math.max
import kotlin.math.sqrt
import kotlin.math.absoluteValue

// ---------------------------------------------------------------
// Custom DecayAnimationSpec that decays toward a fixed target.
class TargetBasedDecay(
    private val target: Offset,
    // Factor to compute duration; tweak as needed.
    private val durationMillisFactor: Float = 2f,
    // Minimum duration.
    private val minDurationMillis: Long = 300L
) : DecayAnimationSpec<Offset> {
    override fun getTargetValue(initialValue: Offset, initialVelocity: Offset): Offset = target

    override fun getDurationMillis(initialValue: Offset, initialVelocity: Offset): Long {
        val distance = (target - initialValue).getDistance()
        return max((distance * durationMillisFactor).toLong(), minDurationMillis)
    }

    override fun getValueAtNanos(initialValue: Offset, initialVelocity: Offset, playTimeNanos: Long): Offset {
        val durationMillis = getDurationMillis(initialValue, initialVelocity)
        val durationNanos = durationMillis * 1_000_000L
        val fraction = playTimeNanos.toFloat() / durationNanos
        val easedFraction = LinearOutSlowInEasing.transform(fraction.coerceIn(0f, 1f))
        return initialValue + (target - initialValue) * easedFraction
    }
}

// Helper extension to compute the magnitude of an Offset vector.
fun Offset.getDistance(): Float = sqrt(x * x + y * y)

// Helper extension to normalize an Offset vector.
fun Offset.normalize(): Offset {
    val mag = getDistance()
    return if (mag > 0f) Offset(x / mag, y / mag) else Offset.Zero
}

// Helper function to return a decay spec: if a target is supplied,
// return our custom TargetBasedDecay; otherwise, default to spline-based decay.
@Composable
fun rememberTargetBasedDecay(target: Offset? = null): DecayAnimationSpec<Offset> {
    return if (target == null) {
        rememberSplineBasedDecay()  // default decay spec
    } else {
        remember { TargetBasedDecay(target) }
    }
}

// ---------------------------------------------------------------
// Unified Composable that animates a flickable box,
// using a single Animatable<Offset> so that X and Y animate together.
@Composable
fun FlickableBoxUnifiedDecayAndSpring(
    // Pass a non-null target if you want the decay phase to naturally finish at a given offset.
    decayTarget: Offset? = Offset(300f, 300f)
) {
    val boxSize = 100.dp
    val boxPxSize = with(androidx.compose.ui.platform.LocalDensity.current) { boxSize.toPx() }
    
    // We'll track the overall parent size (for future use if needed).
    val parentSize = remember { mutableStateOf(IntSize.Zero) }
    
    // Unified Animatable for both X and Y.
    val offset = remember { androidx.compose.animation.core.Animatable(Offset.Zero, Offset.VectorConverter) }
    
    // Get our decay specâ€”either custom target-based or default.
    val decaySpec = rememberTargetBasedDecay(decayTarget)
    
    // Spring spec for the spring-back phase.
    val springSpec = spring<Offset>(
        dampingRatio = androidx.compose.animation.core.Spring.DampingRatioMediumBouncy,
        stiffness = androidx.compose.animation.core.Spring.StiffnessMedium
    )
    
    val scope = rememberCoroutineScope()
    var velocityTracker by remember { mutableStateOf<androidx.compose.ui.input.pointer.VelocityTracker?>(null) }
    
    // Flick threshold in pixels per second.
    val flickVelocityThreshold = 1000f

    Box(
        modifier = Modifier
            .fillMaxSize()
            .onGloballyPositioned { coordinates ->
                parentSize.value = coordinates.size
            }
            .background(Color.LightGray)
    ) {
        Box(
            modifier = Modifier
                .offset {
                    // Convert our Offset to an IntOffset.
                    IntOffset(offset.value.x.roundToInt(), offset.value.y.roundToInt())
                }
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            velocityTracker = androidx.compose.ui.input.pointer.VelocityTracker()
                        },
                        onDrag = { change, dragAmount ->
                            change.consume()
                            velocityTracker?.addPosition(change.uptimeMillis, change.position)
                            scope.launch {
                                // Update our unified offset directly.
                                offset.snapTo(offset.value + dragAmount)
                            }
                        },
                        onDragEnd = {
                            velocityTracker?.let { tracker ->
                                val velocity = tracker.calculateVelocity()
                                val initialVelocity = Offset(velocity.x, velocity.y)
                                val isFlick = 
                                    initialVelocity.x.absoluteValue > flickVelocityThreshold ||
                                    initialVelocity.y.absoluteValue > flickVelocityThreshold
                                
                                scope.launch {
                                    if (isFlick) {
                                        // Run the decay animation with the chosen spec.
                                        // (Since the Animatable is unified, both axes animate together.)
                                        offset.animateDecay(initialVelocity, decaySpec)
                                        
                                        // Chain the spring-back from the current offset to zero.
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = offset.velocity)
                                    } else {
                                        // If not a flick, just spring back immediately.
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = Offset.Zero)
                                    }
                                }
                            }
                        },
                        onDragCancel = {
                            velocityTracker = null
                        }
                    )
                }
                .size(boxSize)
                .background(Color.Blue)
        )
    }
}