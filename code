@Composable
fun FlickableBoxCombinedMotion() {
    val boxSize = 100.dp
    val boxPxSize = with(LocalDensity.current) { boxSize.toPx() }
    val parentSize = remember { mutableStateOf(IntSize.Zero) }
    
    // Use one Animatable holding both x and y together.
    val offset = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    
    // Create a decay animation spec for Offset. This uses the VectorConverter behind the scenes.
    // (It ensures that both axes are animated together.)
    val decay = rememberSplineBasedDecay<Offset>()
    
    // Spring spec for the spring-back phase.
    val springSpec = spring<Offset>(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessMedium
    )
    
    val scope = rememberCoroutineScope()
    var velocityTracker by remember { mutableStateOf<VelocityTracker?>(null) }
    
    // Threshold for flick detection (in pixels per second)
    val flickVelocityThreshold = 1000f

    Box(
        modifier = Modifier
            .fillMaxSize()
            .onGloballyPositioned { coordinates ->
                parentSize.value = coordinates.size
            }
            .background(Color.LightGray)
    ) {
        Box(
            modifier = Modifier
                .offset {
                    // The unified offset controls both x and y
                    IntOffset(offset.value.x.roundToInt(), offset.value.y.roundToInt())
                }
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            velocityTracker = VelocityTracker()
                        },
                        onDrag = { change, dragAmount ->
                            change.consume()
                            velocityTracker?.addPosition(change.uptimeMillis, change.position)
                            scope.launch {
                                // Compute the new offset and clamp it within the parent's bounds.
                                val newOffset = offset.value + dragAmount
                                val clampedX = newOffset.x.coerceIn(0f, parentSize.value.width - boxPxSize)
                                val clampedY = newOffset.y.coerceIn(0f, parentSize.value.height - boxPxSize)
                                offset.snapTo(Offset(clampedX, clampedY))
                            }
                        },
                        onDragEnd = {
                            velocityTracker?.let { tracker ->
                                val velocity = tracker.calculateVelocity()
                                // Convert the velocity into an Offset.
                                val initialVelocity = Offset(velocity.x, velocity.y)
                                // Determine if it qualifies as a flick.
                                val isFlick =
                                    (velocity.x.absoluteValue > flickVelocityThreshold) ||
                                    (velocity.y.absoluteValue > flickVelocityThreshold)
                                
                                scope.launch {
                                    if (isFlick) {
                                        try {
                                            // Run the decay animation for the entire Offset.
                                            offset.animateDecay(initialVelocity, decay) {
                                                // If the value is about to exceed parent bounds, cancel the decay.
                                                val clampedX = value.x.coerceIn(0f, parentSize.value.width - boxPxSize)
                                                val clampedY = value.y.coerceIn(0f, parentSize.value.height - boxPxSize)
                                                if (value.x != clampedX || value.y != clampedY) cancel()
                                            }
                                        } catch (_: CancellationException) {
                                            // Decay cancelled when hitting bounds.
                                        }
                                        // Chain the spring-back animation using the final velocity
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = offset.velocity)
                                    } else {
                                        // No flick detected: spring back immediately (zero initial velocity).
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = Offset.Zero)
                                    }
                                }
                            }
                        },
                        onDragCancel = {
                            velocityTracker = null
                        }
                    )
                }
                .size(boxSize)
                .background(Color.Blue)
        )
    }
}