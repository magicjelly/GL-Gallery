import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.consume
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.launch
import kotlin.math.absoluteValue
import kotlin.math.sqrt

// Extension to compute the magnitude of an Offset vector.
fun Offset.getDistance(): Float = sqrt(x * x + y * y)

// Extension function to normalize an Offset vector.
fun Offset.normalize(): Offset {
    val mag = getDistance()
    return if (mag > 0f) Offset(x / mag, y / mag) else Offset.Zero
}

@Composable
fun FlickableBoxUnifiedDecayAndSpringNoClamps() {
    val boxSize = 100.dp
    // Getting pixel size of the box.
    val boxPxSize = with(LocalDensity.current) { boxSize.toPx() }
    
    // Track parent size (used here for potential future extensions)
    val parentSize = remember { mutableStateOf(IntSize.Zero) }
    
    // Single Animatable for the combined offset
    val offset = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    
    // Decay animation spec for Offset.
    val decay = rememberSplineBasedDecay<Offset>()
    
    // Spring spec for the spring-back phase.
    val springSpec = spring<Offset>(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessMedium
    )
    
    val scope = rememberCoroutineScope()
    var velocityTracker by remember { mutableStateOf<VelocityTracker?>(null) }
    
    // Flick threshold (in pixels per second)
    val flickVelocityThreshold = 1000f
    
    // Maximum total distance allowed during decay before transitioning to spring.
    val maxDecayDistance = 300f

    Box(
        modifier = Modifier
            .fillMaxSize()
            .onGloballyPositioned { coordinates ->
                parentSize.value = coordinates.size
            }
            .background(Color.LightGray)
    ) {
        Box(
            modifier = Modifier
                .offset {
                    // Convert the unified offset to an IntOffset.
                    IntOffset(offset.value.x.roundToInt(), offset.value.y.roundToInt())
                }
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            // Start a new velocity tracker.
                            velocityTracker = VelocityTracker()
                        },
                        onDrag = { change, dragAmount ->
                            change.consume()
                            velocityTracker?.addPosition(change.uptimeMillis, change.position)
                            
                            // Update offset without any clamping.
                            scope.launch {
                                offset.snapTo(offset.value + dragAmount)
                            }
                        },
                        onDragEnd = {
                            velocityTracker?.let { tracker ->
                                val velocity = tracker.calculateVelocity()
                                val initialVelocity = Offset(velocity.x, velocity.y)
                                val isFlick = 
                                    initialVelocity.x.absoluteValue > flickVelocityThreshold ||
                                    initialVelocity.y.absoluteValue > flickVelocityThreshold
                                
                                scope.launch {
                                    if (isFlick) {
                                        // Record the start offset for decay.
                                        val decayStart = offset.value

                                        try {
                                            // Run decay animation, but cancel it once the total displacement
                                            // from decayStart reaches or exceeds maxDecayDistance.
                                            offset.animateDecay(initialVelocity, decay) {
                                                val displacement = (value - decayStart).getDistance()
                                                if (displacement >= maxDecayDistance) cancel()
                                            }
                                        } catch (_: CancellationException) {
                                            // Decay canceled due to reaching maxDecayDistance.
                                        }

                                        // Optionally, smooth out to the exact cap if needed.
                                        val currentDisplacement = (offset.value - decayStart).getDistance()
                                        if (currentDisplacement < maxDecayDistance) {
                                            // Compute target point along the flick direction.
                                            val targetDecay = decayStart + initialVelocity.normalize() * maxDecayDistance
                                            offset.animateTo(
                                                targetDecay,
                                                animationSpec = tween(
                                                    durationMillis = 300,
                                                    easing = LinearOutSlowInEasing
                                                )
                                            )
                                        }

                                        // Chain spring-back animation, using the current velocity.
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = offset.velocity)
                                    } else {
                                        // If not a flick, spring back immediately.
                                        offset.animateTo(Offset.Zero, springSpec, initialVelocity = Offset.Zero)
                                    }
                                }
                            }
                        },
                        onDragCancel = {
                            velocityTracker = null
                        }
                    )
                }
                .size(boxSize)
                .background(Color.Blue)
        )
    }
}