@Composable
fun FlickableBoxWithMaxDecaySmoothStop() {
    val boxSize = 100.dp
    val boxPxSize = with(LocalDensity.current) { boxSize.toPx() }
    
    // Store parent size to clamp dragging.
    val parentSize = remember { mutableStateOf(IntSize.Zero) }
    
    // Use one Animatable for a combined Offset (x and y).
    val offset = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    
    // Create a decay spec for Offset.
    val decay = rememberSplineBasedDecay<Offset>()
    
    // Spring spec for spring-back.
    val springSpec = spring<Offset>(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessMedium
    )
    
    val scope = rememberCoroutineScope()
    var velocityTracker by remember { mutableStateOf<VelocityTracker?>(null) }
    
    // Threshold for a flick (in pixels per second).
    val flickVelocityThreshold = 1000f
    // Maximum offset we want the decay phase to reach.
    val maxDecayOffset = Offset(300f, 300f)
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .onGloballyPositioned { coordinates ->
                parentSize.value = coordinates.size
            }
            .background(Color.LightGray)
    ) {
        Box(
            modifier = Modifier
                .offset { 
                    IntOffset(offset.value.x.roundToInt(), offset.value.y.roundToInt())
                }
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            // Set up a new velocity tracker.
                            velocityTracker = VelocityTracker()
                        },
                        onDrag = { change, dragAmount ->
                            change.consume()
                            velocityTracker?.addPosition(change.uptimeMillis, change.position)
                            scope.launch {
                                val newOffset = offset.value + dragAmount
                                // Clamp so the box always remains visible.
                                val clampedX = newOffset.x.coerceIn(
                                    0f,
                                    (parentSize.value.width - boxPxSize).toFloat()
                                )
                                val clampedY = newOffset.y.coerceIn(
                                    0f,
                                    (parentSize.value.height - boxPxSize).toFloat()
                                )
                                offset.snapTo(Offset(clampedX, clampedY))
                            }
                        },
                        onDragEnd = {
                            velocityTracker?.let { tracker ->
                                val velocity = tracker.calculateVelocity()
                                val initialVelocity = Offset(velocity.x, velocity.y)
                                val isFlick = 
                                    velocity.x.absoluteValue > flickVelocityThreshold ||
                                    velocity.y.absoluteValue > flickVelocityThreshold

                                scope.launch {
                                    if (isFlick) {
                                        // Check what the natural decay target would be.
                                        val predictedTarget = decay.getTargetValue(offset.value, initialVelocity)
                                        
                                        if (predictedTarget.x > maxDecayOffset.x ||
                                            predictedTarget.y > maxDecayOffset.y) {
                                            // Instead of running a full decay (which would overshoot),
                                            // animate smoothly to maxDecayOffset with a tween.
                                            offset.animateTo(
                                                maxDecayOffset,
                                                animationSpec = tween(
                                                    durationMillis = 300,
                                                    easing = LinearOutSlowInEasing
                                                )
                                            )
                                        } else {
                                            // Run normal decay.
                                            try {
                                                offset.animateDecay(initialVelocity, decay)
                                            } catch (_: CancellationException) { }
                                        }
                                        // After decay (or tween) finishes,
                                        // spring back to the target (here, Offset.Zero).
                                        offset.animateTo(
                                            Offset.Zero,
                                            springSpec,
                                            initialVelocity = offset.velocity
                                        )
                                    } else {
                                        // No flick: simply spring back immediately.
                                        offset.animateTo(
                                            Offset.Zero,
                                            springSpec,
                                            initialVelocity = Offset.Zero
                                        )
                                    }
                                }
                            }
                        },
                        onDragCancel = {
                            velocityTracker = null
                        }
                    )
                }
                .size(boxSize)
                .background(Color.Blue)
        )
    }
}