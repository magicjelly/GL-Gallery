@file:Suppress("FunctionName")

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.VectorConverter
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.input.pointer.util.VelocityTracker
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlin.math.*

/**
 * SpatialController = inertia + soft attractor (critically-damped PD, no bounce)
 * Redirectable mid-flight (reads latest target every frame), interruptible (drag cancels loop).
 *
 * Key Tunables (pixels / seconds units):
 * - attractGain: base positional pull toward target (lower = floatier).
 * - damping: velocity damping vs. the attraction (>= ~2.0 to avoid “springy” feel).
 * - captureRadius: distance where we switch to tighter docking gains.
 * - dockGain / dockDamping: precise final approach behavior.
 * - maxAccel: caps instantaneous acceleration for gentler curves on retarget.
 * - maxSpeed: caps velocity to avoid streaking on long throws.
 * - ambientFriction: constant decel (px/s^2) applied opposite to velocity (space “drag”).
 * - redirectSmoothingHz: how quickly the internal target follows setTarget() (0 = instant).
 * - timeStepClampMs: clamps dt for stability on jank frames.
 */
@Stable
class SpatialController(
    private val scope: CoroutineScope,
    start: Offset = Offset.Zero
) {
    private val _pos = Animatable(start, Offset.VectorConverter)
    val pos: Offset get() = _pos.value

    // --- Tunables (good defaults) ---
    var attractGain = 12f             // px/s^2 per px
    var damping = 2.6f                 // unitless; >2 avoids oscillation
    var captureRadius = 32f            // px
    var dockGain = 22f
    var dockDamping = 3.4f
    var maxAccel = 6000f               // px/s^2
    var maxSpeed = 1800f               // px/s   (NEW)
    var ambientFriction = 0f           // px/s^2 (NEW; try 20–60 for subtle fade)
    var redirectSmoothingHz = 6f       // Hz     (NEW; 0 = follow target instantly)
    var timeStepClampMs = 32f          // ms cap for dt

    // --- Internal state ---
    private var vel = Offset.Zero
    private var commandTarget = start      // immediately set by setTarget()
    private var displayTarget = start      // eased toward commandTarget each frame
    private var running = false

    fun setTarget(newTarget: Offset) {
        commandTarget = newTarget
        // if idle, sync display target so it starts from current command target
        if (!running) displayTarget = newTarget
    }

    fun snapTo(newPos: Offset) {
        scope.launch {
            _pos.snapTo(newPos)
            vel = Offset.Zero
        }
    }

    fun addImpulse(v: Offset) { vel += v } // feed release velocity (px/s)

    fun interrupt() { running = false }

    fun start() {
        if (running) return
        running = true
        scope.launch {
            var lastT = 0L
            while (isActive && running) {
                val frameNanos = withFrameNanos { it }
                if (lastT == 0L) { lastT = frameNanos; continue }
                var dt = (frameNanos - lastT) / 1_000_000_000f
                lastT = frameNanos

                // Clamp dt for stability (e.g., GC/jank frames)
                val dtClamp = timeStepClampMs / 1000f
                if (dt > dtClamp) dt = dtClamp

                // --- Redirect smoothing (internal target eases to commanded target) ---
                // Factor per frame using exponential smoothing at `redirectSmoothingHz`
                val s = if (redirectSmoothingHz <= 0f) 1f
                        else (1f - exp(-redirectSmoothingHz * dt))
                displayTarget += (commandTarget - displayTarget) * s

                // Pick gains based on distance (capture vs dock)
                val delta = displayTarget - _pos.value
                val dist = delta.getDistance()
                val k = if (dist < captureRadius) dockGain else attractGain
                val c = if (dist < captureRadius) dockDamping else damping

                // Critically-damped like PD: a = k*delta - c*vel
                var accel = delta * k - vel * c

                // Ambient friction (constant decel opposite to velocity)
                if (ambientFriction > 0f && vel != Offset.Zero) {
                    val speed = vel.getDistance()
                    if (speed > 1e-3f) {
                        val friction = min(ambientFriction, speed / dt)
                        accel += (-vel / speed) * friction
                    }
                }

                // Clamp acceleration magnitude
                val aMag = accel.getDistance()
                if (aMag > maxAccel) accel *= (maxAccel / aMag)

                // Integrate velocity & clamp speed
                vel += accel * dt
                val speed = vel.getDistance()
                if (speed > maxSpeed) vel *= (maxSpeed / speed)

                // Integrate position
                val next = _pos.value + vel * dt
                _pos.snapTo(next)
            }
        }
    }
}

// --------------------- Demo Composable ---------------------

@Composable
fun SpatialRedirectableDemo() {
    val scope = rememberCoroutineScope()
    val controller = remember { SpatialController(scope) }

    // Tuning example (adjust as desired)
    LaunchedEffect(Unit) {
        controller.attractGain = 12f
        controller.damping = 2.6f
        controller.captureRadius = 36f
        controller.dockGain = 22f
        controller.dockDamping = 3.6f
        controller.maxAccel = 7000f
        controller.maxSpeed = 2000f       // NEW
        controller.ambientFriction = 35f  // NEW
        controller.redirectSmoothingHz = 7f // NEW
    }

    // Live target (can change anytime; motion redirects mid-flight)
    var target by remember { mutableStateOf(Offset(800f, 1200f)) }

    // Keep controller target synced and running
    LaunchedEffect(target) { controller.setTarget(target); controller.start() }

    Box(Modifier.fillMaxSize().background(Color(0xFF0F1115))) {
        // Drag to interrupt + reposition; release → continue with inertia and re-capture
        val vt = remember { VelocityTracker() }
        Box(
            Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            vt.resetTracking()
                            controller.interrupt() // stop loop while user takes control
                        },
                        onDrag = { change, drag ->
                            change.consume()
                            vt.addPosition(change.uptimeMillis, change.position)
                            controller.snapTo(controller.pos + drag)
                        },
                        onDragEnd = {
                            val v = vt.calculateVelocity()
                            controller.addImpulse(Offset(v.x, v.y)) // px/s
                            controller.start() // resume toward latest target
                        },
                        onDragCancel = { controller.start() }
                    )
                }
        )

        // Example retarget buttons (corners). Tap to change destination mid-flight.
        RetargetButtons { newTarget ->
            target = newTarget
        }

        // Moving component
        Box(
            Modifier
                .size(56.dp)
                .offset {
                    IntOffset(controller.pos.x.roundToInt(), controller.pos.y.roundToInt())
                }
                .background(Color.White)
        )
    }
}

// -------------- Utilities --------------

@Composable
private fun RetargetButtons(onPick: (Offset) -> Unit) {
    // Four translucent pads; adapt to your layout system as needed.
    val pad = 72.dp
    // Positions below are arbitrary demo values in dp; map to px as needed in your app.
    Box(Modifier.fillMaxSize()) {
        RetargetPad(16.dp, 16.dp, pad) { onPick(Offset(120f, 120f)) }
        RetargetPad(300.dp, 16.dp, pad) { onPick(Offset(900f, 120f)) }
        RetargetPad(16.dp, 600.dp, pad) { onPick(Offset(120f, 1400f)) }
        RetargetPad(300.dp, 600.dp, pad) { onPick(Offset(900f, 1400f)) }
    }
}

@Composable
private fun RetargetPad(x: Dp, y: Dp, size: Dp, onTap: () -> Unit) {
    Box(
        Modifier
            .offset(x, y)
            .size(size)
            .background(Color(0x22FFFFFF))
            .pointerInput(Unit) { detectDragGestures(onDragStart = { onTap() }) }
    )
}

// --- math helpers ---
private operator fun Offset.plus(o: Offset) = Offset(x + o.x, y + o.y)
private operator fun Offset.minus(o: Offset) = Offset(x - o.x, y - o.y)
private operator fun Offset.times(s: Float) = Offset(x * s, y * s)
private operator fun Offset.div(s: Float) = Offset(x / s, y / s)