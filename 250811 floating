@file:Suppress("FunctionName")

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.VectorConverter
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.runtime.withFrameNanos
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.input.pointer.util.VelocityTracker
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlin.math.*

/** Redirectable, interruptible spatial controller (no bounce; inertia + soft attractor). */
@Stable
class SpatialController(
    private val scope: CoroutineScope,
    start: Offset = Offset.Zero
) {
    private val _pos = Animatable(start, Offset.VectorConverter)
    val pos: Offset get() = _pos.value

    // ---- Tunables (good defaults) ----
    var attractGain = 12f            // base pull toward target (lower = floatier)
    var damping = 2.6f               // >2 avoids oscillation
    var captureRadius = 36f          // switch to docking when within this distance (px)
    var dockGain = 22f               // stronger pull near target
    var dockDamping = 3.6f
    var maxAccel = 7000f             // px/s^2 clamp
    var maxSpeed = 2000f             // px/s clamp
    var ambientFriction = 35f        // px/s^2 constant decel (0 to disable)
    var redirectSmoothingHz = 7f     // 0 = instant retarget; higher = smoother
    var timeStepClampMs = 32f        // clamp dt for stability

    // ---- Internal ----
    private var vel = Offset.Zero
    private var commandTarget = start
    private var displayTarget = start
    private var running = false

    fun setTarget(newTarget: Offset) {
        commandTarget = newTarget
        if (!running) displayTarget = newTarget
    }

    fun snapTo(newPos: Offset) {
        scope.launch {
            _pos.snapTo(newPos)
            vel = Offset.Zero
        }
    }

    fun addImpulse(v: Offset) { vel += v }   // px/s from release velocity
    fun interrupt() { running = false }

    fun start() {
        if (running) return
        running = true
        scope.launch {
            var lastT = 0L
            while (isActive && running) {
                val now = withFrameNanos { it }
                if (lastT == 0L) { lastT = now; continue }
                var dt = (now - lastT) / 1_000_000_000f
                lastT = now

                // dt clamp
                val dtMax = timeStepClampMs / 1000f
                if (dt > dtMax) dt = dtMax

                // Smooth retarget
                val s = if (redirectSmoothingHz <= 0f) 1f else (1f - exp(-redirectSmoothingHz * dt))
                displayTarget += (commandTarget - displayTarget) * s

                // Gains by distance (capture vs dock)
                val delta = displayTarget - _pos.value
                val dist = delta.getDistance()
                val k = if (dist < captureRadius) dockGain else attractGain
                val c = if (dist < captureRadius) dockDamping else damping

                // PD-like accel (no bounce)
                var accel = delta * k - vel * c

                // Ambient friction
                if (ambientFriction > 0f) {
                    val speed = vel.getDistance()
                    if (speed > 1e-3f) {
                        val friction = min(ambientFriction, speed / dt)
                        accel += (-vel / speed) * friction
                    }
                }

                // Clamp accel
                val aMag = accel.getDistance()
                if (aMag > maxAccel) accel *= (maxAccel / aMag)

                // Integrate, clamp speed
                vel += accel * dt
                val speed = vel.getDistance()
                if (speed > maxSpeed) vel *= (maxSpeed / speed)

                // Move
                _pos.snapTo(_pos.value + vel * dt)
            }
        }
    }
}

// ---------------- Demo (bigger touch target; visual stays small) ----------------

@Composable
fun SpatialRedirectableDemo() {
    val scope = rememberCoroutineScope()
    val controller = remember { SpatialController(scope) }

    // Live target; update however you like (buttons below are just a demo)
    var target by remember { mutableStateOf(Offset(800f, 1200f)) }
    LaunchedEffect(target) { controller.setTarget(target); controller.start() }

    val visualSize = 56.dp
    val touchSize = 96.dp
    val vt = remember { VelocityTracker() }

    Box(Modifier.fillMaxSize().background(Color(0xFF0F1115))) {
        // Tap anywhere (four pads) to change target; motion will redirect mid-flight
        RetargetPads { target = it }

        // DRAG ONLY ON THE OBJECT (larger invisible hit area)
        Box(
            Modifier
                .size(touchSize)
                .offset { IntOffset(controller.pos.x.roundToInt(), controller.pos.y.roundToInt()) }
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            vt.resetTracking()
                            controller.interrupt()
                        },
                        onDrag = { change, drag ->
                            change.consume()
                            vt.addPosition(change.uptimeMillis, change.position)
                            controller.snapTo(controller.pos + drag)
                        },
                        onDragEnd = {
                            val v = vt.calculateVelocity()
                            controller.addImpulse(Offset(v.x, v.y))
                            controller.start()
                        },
                        onDragCancel = { controller.start() }
                    )
                },
            contentAlignment = Alignment.Center
        ) {
            Box(Modifier.size(visualSize).background(Color.White))
        }
    }
}

// Four corner pads to set new targets (for demo)
@Composable
private fun RetargetPads(onPick: (Offset) -> Unit) {
    BoxWithConstraints(Modifier.fillMaxSize()) {
        val wPx = constraints.maxWidth.toFloat()
        val hPx = constraints.maxHeight.toFloat()
        fun place(alignment: Alignment, tx: Float, ty: Float) {
            Box(
                Modifier
                    .size(72.dp)
                    .align(alignment)
                    .background(Color(0x22FFFFFF))
                    .pointerInput(Unit) {
                        detectTapGestures {
                            onPick(Offset(tx * wPx, ty * hPx))
                        }
                    }
            )
        }
        place(Alignment.TopStart,    0.1f, 0.1f)
        place(Alignment.TopEnd,      0.9f, 0.1f)
        place(Alignment.BottomStart, 0.1f, 0.9f)
        place(Alignment.BottomEnd,   0.9f, 0.9f)
    }
}

// --- math helpers ---
private operator fun Offset.plus(o: Offset) = Offset(x + o.x, y + o.y)
private operator fun Offset.minus(o: Offset) = Offset(x - o.x, y - o.y)
private operator fun Offset.times(s: Float) = Offset(x * s, y * s)
private operator fun Offset.div(s: Float) = Offset(x / s, y / s)