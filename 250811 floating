@file:Suppress("FunctionName")

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.VectorConverter
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.input.pointer.util.VelocityTracker
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlin.math.*

/**
 * SpatialController = inertia + soft attractor (critically-damped PD, no bounce)
 * Redirectable mid-flight (reads latest target every frame), interruptible (drag cancels loop).
 *
 * Primary knobs (spring-like):
 * - pullStrength: 0.5..1.5 (≈ stiffness)
 * - dragRatio:    0.7..1.4 (≈ dampingRatio)
 * - floatiness:   0.0..1.0 (spacey drift)
 * - mass:         0.5..2.0 (inertia)
 */
@Stable
class SpatialController(
    private val scope: CoroutineScope,
    start: Offset = Offset.Zero
) {
    private val _pos = Animatable(start, Offset.VectorConverter)
    val pos: Offset get() = _pos.value

    // Internals auto-mapped from knobs
    var attractGain = 12f
    var damping = 2.6f
    var captureRadius = 32f
    var dockGain = 22f
    var dockDamping = 3.4f
    var maxAccel = 6000f
    var maxSpeed = 1800f
    var ambientFriction = 0f
    var redirectSmoothingHz = 6f
    var timeStepClampMs = 32f

    // Public knobs
    var pullStrength = 1.0f; private set
    var dragRatio = 1.0f; private set
    var floatiness = 0.3f; private set
    var mass = 1.0f; private set

    private var vel = Offset.Zero
    private var commandTarget = start
    private var displayTarget = start
    private var running = false

    fun applySpaceTuning(
        pullStrength: Float = this.pullStrength,
        dragRatio: Float = this.dragRatio,
        floatiness: Float = this.floatiness,
        mass: Float = this.mass
    ) {
        this.pullStrength = pullStrength
        this.dragRatio = dragRatio
        this.floatiness = floatiness.coerceIn(0f, 1f)
        this.mass = mass

        val baseAttract = 12f
        val baseDockAttract = 22f
        val baseDamping = 2.6f
        val baseDockDamping = 3.4f
        val baseFrictionMax = 60f
        val baseMaxAccel = 6000f
        val baseMaxSpeed = 1800f
        val baseRedirectHz = 6f
        val m = mass.coerceAtLeast(0.2f)

        attractGain   = (baseAttract * pullStrength) / m
        dockGain      = (baseDockAttract * pullStrength) / m

        val massDampScale = 1f / sqrt(m)
        damping      = (baseDamping * dragRatio) * massDampScale
        dockDamping  = (baseDockDamping * dragRatio) * massDampScale
        if (damping < 2f) damping = 2f
        if (dockDamping < 2.5f) dockDamping = 2.5f

        ambientFriction = lerp(baseFrictionMax, 0f, this.floatiness) / m
        captureRadius   = lerp(28f, 44f, this.floatiness)
        redirectSmoothingHz = lerp(baseRedirectHz, baseRedirectHz * 1.6f, this.floatiness)

        maxAccel = (baseMaxAccel * pullStrength) / m
        maxSpeed = (baseMaxSpeed * (0.9f + 0.4f * this.floatiness)) / sqrt(m)
    }

    fun setTarget(newTarget: Offset) {
        commandTarget = newTarget
        if (!running) displayTarget = newTarget
    }

    fun snapTo(newPos: Offset) {
        scope.launch { _pos.snapTo(newPos); vel = Offset.Zero }
    }

    fun addImpulse(v: Offset) { vel += v }
    fun interrupt() { running = false }

    fun start() {
        if (running) return
        running = true
        scope.launch {
            var lastT = 0L
            while (isActive && running) {
                val frameNanos = withFrameNanos { it }
                if (lastT == 0L) { lastT = frameNanos; continue }
                var dt = (frameNanos - lastT) / 1_000_000_000f
                lastT = frameNanos

                val dtClamp = timeStepClampMs / 1000f
                if (dt > dtClamp) dt = dtClamp

                val s = if (redirectSmoothingHz <= 0f) 1f else (1f - exp(-redirectSmoothingHz * dt))
                displayTarget += (commandTarget - displayTarget) * s

                val delta = displayTarget - _pos.value
                val dist = delta.getDistance()
                val k = if (dist < captureRadius) dockGain else attractGain
                val c = if (dist < captureRadius) dockDamping else damping

                var accel = delta * k - vel * c

                if (ambientFriction > 0f && vel != Offset.Zero) {
                    val speed = vel.getDistance()
                    if (speed > 1e-3f) {
                        val friction = min(ambientFriction, speed / dt)
                        accel += (-vel / speed) * friction
                    }
                }

                val aMag = accel.getDistance()
                if (aMag > maxAccel) accel *= (maxAccel / aMag)

                vel += accel * dt
                val speed = vel.getDistance()
                if (speed > maxSpeed) vel *= (maxSpeed / speed)

                _pos.snapTo(_pos.value + vel * dt)
            }
        }
    }
}

@Composable
fun SpatialRedirectableDemo() {
    val scope = rememberCoroutineScope()
    val controller = remember { SpatialController(scope) }

    // Slider state
    var pullStrength by remember { mutableStateOf(1.0f) }
    var dragRatio by remember { mutableStateOf(1.0f) }
    var floatiness by remember { mutableStateOf(0.3f) }
    var mass by remember { mutableStateOf(1.0f) }

    // Presets
    data class Preset(val name: String, val pull: Float, val drag: Float, val flo: Float, val mass: Float)
    val presets = listOf(
        Preset("Crisp",     1.3f, 1.2f, 0.1f, 1.0f),
        Preset("Balanced",  1.0f, 1.0f, 0.3f, 1.0f),
        Preset("Floaty",    0.8f, 0.9f, 0.7f, 1.2f),
    )
    var selectedPreset by remember { mutableStateOf("Balanced") }
    val eps = 0.01f
    fun matches(p: Preset) =
        abs(pullStrength - p.pull) < eps &&
        abs(dragRatio - p.drag) < eps &&
        abs(floatiness - p.flo) < eps &&
        abs(mass - p.mass) < eps

    // Apply knobs to controller
    LaunchedEffect(pullStrength, dragRatio, floatiness, mass) {
        controller.applySpaceTuning(pullStrength, dragRatio, floatiness, mass)
        // Auto-select Custom if sliders deviate from chosen preset
        selectedPreset = presets.firstOrNull { matches(it) }?.name ?: "Custom"
    }

    // Controls collapsible
    var controlsExpanded by remember { mutableStateOf(true) }

    var target by remember { mutableStateOf(Offset(800f, 1200f)) }
    LaunchedEffect(target) { controller.setTarget(target); controller.start() }

    val vt = remember { VelocityTracker() }

    Column(Modifier.fillMaxSize().background(Color(0xFF0F1115))) {

        Row(
            Modifier.fillMaxWidth().padding(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text("Motion Controls", color = Color.White, modifier = Modifier.weight(1f))
            TextButton(onClick = { controlsExpanded = !controlsExpanded }) {
                Text(if (controlsExpanded) "Hide" else "Show", color = Color.White)
            }
        }

        AnimatedVisibility(visible = controlsExpanded) {
            Column {
                SliderWithLabel("Pull Strength", pullStrength, 0.5f, 1.5f) { pullStrength = it }
                SliderWithLabel("Drag Ratio",    dragRatio,    0.7f, 1.4f) { dragRatio = it }
                SliderWithLabel("Floatiness",    floatiness,   0f,   1f   ) { floatiness = it }
                SliderWithLabel("Mass",          mass,         0.5f, 2f   ) { mass = it }

                // Preset Radios (+ Custom)
                Column(Modifier.padding(horizontal = 16.dp, vertical = 8.dp)) {
                    Text("Quick Tuning", color = Color.White)
                    presets.forEach { p ->
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            RadioButton(
                                selected = selectedPreset == p.name,
                                onClick = {
                                    selectedPreset = p.name
                                    pullStrength = p.pull
                                    dragRatio = p.drag
                                    floatiness = p.flo
                                    mass = p.mass
                                }
                            )
                            Text(p.name, color = Color.White)
                        }
                    }
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        RadioButton(
                            selected = selectedPreset == "Custom",
                            onClick = { selectedPreset = "Custom" } // keep current slider values
                        )
                        Text("Custom", color = Color.White)
                    }
                }
                Divider(color = Color.White.copy(alpha = 0.1f))
            }
        }

        Box(
            Modifier.weight(1f).fillMaxWidth()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = {
                            vt.resetTracking()
                            controller.interrupt()
                        },
                        onDrag = { change, drag ->
                            change.consume()
                            vt.addPosition(change.uptimeMillis, change.position)
                            controller.snapTo(controller.pos + drag)
                        },
                        onDragEnd = {
                            val v = vt.calculateVelocity()
                            controller.addImpulse(Offset(v.x, v.y))
                            controller.start()
                        },
                        onDragCancel = { controller.start() }
                    )
                }
        ) {
            RetargetPads { newTarget -> target = newTarget }

            Box(
                Modifier
                    .size(56.dp)
                    .offset { IntOffset(controller.pos.x.roundToInt(), controller.pos.y.roundToInt()) }
                    .background(Color.White)
            )
        }
    }
}

// --- UI helpers ---

@Composable
private fun SliderWithLabel(label: String, value: Float, min: Float, max: Float, onChange: (Float) -> Unit) {
    Column(Modifier.padding(horizontal = 16.dp, vertical = 6.dp)) {
        Text("$label: ${"%.2f".format(value)}", color = Color.White)
        Slider(value = value, onValueChange = onChange, valueRange = min..max)
    }
}

// Four corner pads to set new targets (for demo)
@Composable
private fun RetargetPads(onPick: (Offset) -> Unit) {
    BoxWithConstraints(Modifier.fillMaxSize()) {
        val wPx = constraints.maxWidth.toFloat()
        val hPx = constraints.maxHeight.toFloat()
        fun place(alignment: Alignment, tx: Float, ty: Float) {
            Box(
                Modifier
                    .size(72.dp)
                    .align(alignment)
                    .background(Color(0x22FFFFFF))
                    .pointerInput(Unit) {
                        detectTapGestures { onPick(Offset(tx * wPx, ty * hPx)) }
                    }
            )
        }
        place(Alignment.TopStart,    0.1f, 0.1f)
        place(Alignment.TopEnd,      0.9f, 0.1f)
        place(Alignment.BottomStart, 0.1f, 0.9f)
        place(Alignment.BottomEnd,   0.9f, 0.9f)
    }
}

// --- math helpers ---
private fun lerp(a: Float, b: Float, t: Float) = a + (b - a) * t
private operator fun Offset.plus(o: Offset) = Offset(x + o.x, y + o.y)
private operator fun Offset.minus(o: Offset) = Offset(x - o.x, y - o.y)
private operator fun Offset.times(s: Float) = Offset(x * s, y * s)
private operator fun Offset.div(s: Float) = Offset(this.x / s, this.y / s)