// Axis rule: X-motion → WIDTH elongates; Y-motion → HEIGHT elongates
// Slow travel: stiffness = 50f, critical damping
// Starts at center of screen
// Full-screen tap, 100.dp box, fixed orientation, no shadow/white

@file:Suppress("MagicNumber")

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.pow

@Composable
fun ReactiveMotion_AxisExact_Slow_Centered() {
    val objSize = 100.dp
    val density = LocalDensity.current
    val sizePx = with(density) { objSize.toPx() }

    // Position spring: stiffness 50, critical damping
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(dampingRatio = 1f, stiffness = 50f)

    // Deformation spring
    val stretch = remember { Animatable(1f) }
    val deformSpring = spring<Float>(dampingRatio = 1.05f, stiffness = Spring.StiffnessLow)

    // Visible deformation
    val MAX_STRETCH = 2.0f
    val MIN_SQUASH = 1f / MAX_STRETCH
    val VEL_FOR_MAX = 380f
    val AXIS_SHARPNESS = 2.0f
    val CLOSE_EPS = with(density) { 18.dp.toPx() }

    val VLPF = 0.55f
    val SLPF = 0.55f

    var lastP by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFilt by remember { mutableStateOf(Offset.Zero) }
    var speedFilt by remember { mutableStateOf(0f) }

    var latestTarget by remember { mutableStateOf(Offset.Zero) }
    var stretchTarget by remember { mutableStateOf(1f) }

    // Place box at center on first composition
    LaunchedEffect(Unit) {
        // Wait until layout gives us size
        pos.snapTo(Offset.Zero) // will be replaced once we know screen size
    }

    // Observe pos for deformation
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f
            val v = (p - lastP) * (1f / dt)
            vFilt = vFilt * VLPF + v * (1f - VLPF)

            val speed = hypot(vFilt.x, vFilt.y)
            speedFilt = speedFilt * SLPF + speed * (1f - SLPF)

            var target = 1f + (MAX_STRETCH - 1f) *
                (1f - (1f - (speedFilt / VEL_FOR_MAX).coerceIn(0f, 1f)).let { it * it })

            if ((latestTarget - p).getDistance() < CLOSE_EPS) target = 1f
            if (kotlin.math.abs(target - stretchTarget) > 0.002f) stretchTarget = target

            lastP = p; lastT = now
        }
    }

    LaunchedEffect(stretchTarget) {
        stretch.animateTo(stretchTarget, deformSpring)
    }

    val scope = rememberCoroutineScope()

    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(tgt, animationSpec = posSpring)
                        stretch.animateTo(1f, deformSpring)
                    }
                }
            },
        contentAlignment = Alignment.TopStart
    ) {
        // Center initialization
        LaunchedEffect(maxWidth, maxHeight) {
            val center = Offset(maxWidth.toPx() / 2f, maxHeight.toPx() / 2f)
            pos.snapTo(center)
        }

        // Axis mapping: X → width↑ ; Y → height↑
        val ax = abs(vFilt.x); val ay = abs(vFilt.y)
        val axP = ax.pow(AXIS_SHARPNESS); val ayP = ay.pow(AXIS_SHARPNESS)
        val sum = (axP + ayP).coerceAtLeast(1e-3f)
        val wx = axP / sum; val wy = 1f - wx

        val s = stretch.value.coerceIn(1f, MAX_STRETCH)
        val inv = (1f / s).coerceIn(MIN_SQUASH, 1f)

        val scaleX = inv * wy + s * wx
        val scaleY = s * wy + inv * wx

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .graphicsLayer {
                    rotationZ = 0f
                    shadowElevation = 0f
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
                .background(Color(0xFF1EB980))
        )
    }
}