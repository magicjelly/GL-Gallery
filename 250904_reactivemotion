// Opposite-tail elongation:
// - If moving RIGHT → stretch to the LEFT (anchor right edge)
// - If moving LEFT  → stretch to the RIGHT (anchor left edge)
// - If moving DOWN  → stretch UP (anchor bottom edge)
// - If moving UP    → stretch DOWN (anchor top edge)
// + Axis-aware (X → width elongates, Y → height elongates)
// + Slow travel: stiffness=50, critical damping
// + Starts centered, full-screen tap, 100.dp box

@file:Suppress("MagicNumber")

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.TransformOrigin
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow

@Composable
fun ReactiveMotion_OppositeTail() {
    val objSize = 100.dp
    val density = LocalDensity.current
    val sizePx = with(density) { objSize.toPx() }

    // Slow position spring (stiffness 50, critically damped)
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(dampingRatio = 1f, stiffness = 50f)

    // Deformation spring
    val stretch = remember { Animatable(1f) }
    val deformSpring = spring<Float>(dampingRatio = 1.05f, stiffness = Spring.StiffnessLow)

    // Visible deformation
    val MAX_STRETCH = 2.0f
    val MIN_SQUASH  = 1f / MAX_STRETCH
    val VEL_FOR_MAX = 380f
    val AXIS_SHARPNESS = 2.0f
    val CLOSE_EPS = with(density) { 18.dp.toPx() }

    // Filters
    val VLPF = 0.55f
    val SLPF = 0.55f

    // Kinematics
    var lastP by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFilt by remember { mutableStateOf(Offset.Zero) }
    var speedFilt by remember { mutableStateOf(0f) }

    var latestTarget by remember { mutableStateOf(Offset.Zero) }
    var stretchTarget by remember { mutableStateOf(1f) }

    // Center on first layout
    var didCenter by remember { mutableStateOf(false) }

    // Deformation driver (by SPEED ⇒ elongate while fast, return as it slows)
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f
            val v = (p - lastP) * (1f / dt)
            vFilt = vFilt * VLPF + v * (1f - VLPF)

            val speed = hypot(vFilt.x, vFilt.y)
            speedFilt = speedFilt * SLPF + speed * (1f - SLPF)

            val t = (speedFilt / VEL_FOR_MAX).coerceIn(0f, 1f)
            var target = 1f + (MAX_STRETCH - 1f) * easeOut(t)

            if ((latestTarget - p).getDistance() < CLOSE_EPS) target = 1f
            if (kotlin.math.abs(target - stretchTarget) > 0.002f) stretchTarget = target

            lastP = p; lastT = now
        }
    }
    LaunchedEffect(stretchTarget) { stretch.animateTo(stretchTarget, deformSpring) }

    val scope = rememberCoroutineScope()

    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(tgt, animationSpec = posSpring)
                        stretch.animateTo(1f, deformSpring) // ensure exact rest
                    }
                }
            }
    ) {
        if (!didCenter) {
            val center = with(density) { Offset(maxWidth.toPx() / 2f, maxHeight.toPx() / 2f) }
            LaunchedEffect(Unit) {
                pos.snapTo(center)
                didCenter = true
            }
        }

        // Axis dominance (soft-argmax) + sign
        val vx = vFilt.x; val vy = vFilt.y
        val ax = abs(vx); val ay = abs(vy)
        val axP = ax.pow(AXIS_SHARPNESS); val ayP = ay.pow(AXIS_SHARPNESS)
        val sum = (axP + ayP).coerceAtLeast(1e-3f)
        val wx = axP / sum          // X dominance weight
        val wy = 1f - wx            // Y dominance weight
        val signX = if (vx >= 0f) 1f else -1f
        val signY = if (vy >= 0f) 1f else -1f

        // Scale mapping (axis-aware)
        val s = stretch.value.coerceIn(1f, MAX_STRETCH)
        val inv = (1f / s).coerceIn(MIN_SQUASH, 1f)
        // X-motion → width↑ ; Y-motion → height↑ (blended)
        val scaleX = inv * wy + s * wx
        val scaleY = s * wy + inv * wx

        // Opposite-tail anchoring via transformOrigin:
        // - X-dominant: anchor leading edge (right when moving right, left when moving left)
        // - Y-dominant: anchor leading edge (bottom when moving down, top when moving up)
        val originX = when {
            wx >= 0.5f && signX > 0 -> 1f      // moving right → anchor right (stretch left)
            wx >= 0.5f && signX < 0 -> 0f      // moving left  → anchor left  (stretch right)
            else -> 0.5f                       // Y-dominant → center X
        }
        val originY = when {
            wy > 0.5f && signY > 0 -> 1f       // moving down → anchor bottom (stretch up)
            wy > 0.5f && signY < 0 -> 0f       // moving up   → anchor top    (stretch down)
            else -> 0.5f                       // X-dominant → center Y
        }

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .graphicsLayer {
                    rotationZ = 0f
                    shadowElevation = 0f
                    transformOrigin = TransformOrigin(originX, originY)
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
                .background(Color(0xFF1EB980))
        )
    }
}

private fun easeOut(t: Float) = 1f - (1f - t) * (1f - t)