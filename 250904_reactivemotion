// Reactive motion: axis-aware elongation, smooth return synced to arrival
// - If moving in Y → elongate WIDTH (scaleX↑, scaleY↓)
// - If moving in X → elongate HEIGHT (scaleY↑, scaleX↓)
// - Return-to-original size is smooth and completes as the box arrives
// - Full-screen tap; box = 100.dp; fixed orientation; no shadow/white

@file:Suppress("MagicNumber")

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.spring
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min

@Composable
fun ReactiveMotionAxisAware() {
    val density = LocalDensity.current
    val objSize = 100.dp
    val sizePx = with(density) { objSize.toPx() }

    // Position spring: slow, slightly overdamped
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(dampingRatio = 1.05f, stiffness = Spring.StiffnessVeryLow)

    // Deformation spring: fast-enough to finish by arrival, smooth (overdamped)
    val stretch = remember { Animatable(1f) }
    val deformSpring = spring<Float>(dampingRatio = 1.05f, stiffness = Spring.StiffnessLow)

    // Latest target to compute remaining distance
    var latestTarget by remember { mutableStateOf(Offset.Zero) }

    // Mapping & smoothing
    val MAX_STRETCH = 1.25f           // cap
    val MIN_SQUASH  = 1f / MAX_STRETCH
    val VEL_FOR_MAX = 600f            // speed at which stretch≈MAX
    val LPF = 0.9f                    // heavy velocity smoothing
    val CLOSE_EPS = with(density) { 18.dp.toPx() } // "arrived" threshold

    // Velocity estimate (filtered)
    var last by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFiltered by remember { mutableStateOf(Offset.Zero) }

    // Drive stretch target (decoupled to avoid jank)
    var stretchTarget by remember { mutableStateOf(1f) }

    // Observe pos → update filtered velocity & stretch target
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f
            val v = (p - last) * (1f / dt)
            vFiltered = vFiltered * LPF + v * (1f - LPF)

            val remaining = (latestTarget - p).getDistance()
            val speed = hypot(vFiltered.x, vFiltered.y)

            val t = (speed / VEL_FOR_MAX).coerceIn(0f, 1f)
            val mapped = 1f + (MAX_STRETCH - 1f) * easeOutQuad(t)

            // If we're very close to target, force return to 1 to finish exactly on arrival
            val target = if (remaining < CLOSE_EPS) 1f else mapped

            // Rate-limit updates to prevent micro-jitter
            if (kotlin.math.abs(target - stretchTarget) > 0.006f) {
                stretchTarget = target
            }

            last = p; lastT = now
        }
    }

    // Smooth spring toward target (separate animator)
    LaunchedEffect(stretchTarget) {
        stretch.animateTo(stretchTarget, deformSpring)
    }

    val scope = rememberCoroutineScope()

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(
                            tgt,
                            animationSpec = posSpring,
                            initialVelocity = vFiltered
                        )
                        // Safety: ensure exact rest at end
                        stretch.animateTo(1f, deformSpring)
                    }
                }
            },
        contentAlignment = Alignment.TopStart
    ) {
        // Axis-aware elongation:
        // wy≈1 when |vy|≫|vx| ⇒ elongate WIDTH; wy≈0 when |vx|≫|vy| ⇒ elongate HEIGHT.
        val ax = abs(vFiltered.x)
        val ay = abs(vFiltered.y)
        val denom = (ax + ay).coerceAtLeast(1e-3f)
        val wy = ay / denom                      // weight for Y-dominant motion
        val s = stretch.value                    // [1, MAX_STRETCH]
        val inv = (1f / s).coerceAtLeast(MIN_SQUASH)

        // Blend between the two rules to avoid snapping at axis crossover
        // wy=1 → (scaleX=s, scaleY=inv), wy=0 → (scaleX=inv, scaleY=s)
        val scaleX = lerp(inv, s, wy).coerceIn(MIN_SQUASH, MAX_STRETCH)
        val scaleY = lerp(s, inv, wy).coerceIn(MIN_SQUASH, MAX_STRETCH)

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .background(Color(0xFF2196F3))
                .graphicsLayer {
                    rotationZ = 0f
                    shadowElevation = 0f
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
        )
    }
}

private fun lerp(a: Float, b: Float, t: Float) = a + (b - a) * t
private fun easeOutQuad(t: Float) = 1f - (1f - t) * (1f - t)