@file:Suppress("MagicNumber")

import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.TransformOrigin
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.pow

@Composable
fun ReactiveMotion_DistanceLinked() {
    val objSize = 100.dp
    val density = LocalDensity.current
    val sizePx = with(density) { objSize.toPx() }

    // Position spring: slow, critically damped
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(dampingRatio = 1f, stiffness = 50f)

    // Elongation in *pixels* (extra length), spring-matched to position
    val elongPx = remember { Animatable(0f) }
    val elongSpring = spring<Float>(dampingRatio = 1f, stiffness = 50f)

    // Cap: max extra length (px)
    val MAX_ELONG_PX = with(density) { 140.dp.toPx() }

    // Track the start of each move to measure distance c
    var moveStart by remember { mutableStateOf(Offset.Zero) }
    var latestTarget by remember { mutableStateOf(Offset.Zero) }

    // Velocity (for matching elongation velocity)
    var lastP by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFilt by remember { mutableStateOf(Offset.Zero) }
    val VLPF = 0.6f

    val scope = rememberCoroutineScope()

    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    moveStart = pos.value              // reset displacement origin
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(tgt, posSpring)
                        elongPx.animateTo(0f, elongSpring) // pin to rest at end
                    }
                }
            }
    ) {
        // Start centered
        LaunchedEffect(maxWidth, maxHeight) {
            val center = with(density) { Offset(maxWidth.toPx() / 2f, maxHeight.toPx() / 2f) }
            pos.snapTo(center)
            moveStart = center
        }

        // Compute 1:1 elongation = |displacement along dominant axis| (clamped)
        LaunchedEffect(Unit) {
            snapshotFlow { pos.value }.collect { p ->
                val now = System.nanoTime()
                val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f
                val v = (p - lastP) * (1f / dt)
                vFilt = vFilt * VLPF + v * (1f - VLPF)

                val dx = p.x - moveStart.x
                val dy = p.y - moveStart.y
                val xDominant = abs(dx) >= abs(dy)

                val c = if (xDominant) abs(dx) else abs(dy)                    // distance c
                val targetElong = c.coerceAtMost(MAX_ELONG_PX)

                // Match rates: elong velocity = projection of v onto dominant axis (signed)
                val vAxis = if (xDominant) abs(vFilt.x) else abs(vFilt.y)

                elongPx.animateTo(
                    targetValue = targetElong,
                    animationSpec = elongSpring,
                    initialVelocity = vAxis        // px/s → matches perceived rate
                )

                lastP = p; lastT = now
            }
        }

        // Render with opposite-tail anchoring and fixed leading edge
        val center = pos.value
        val dx = center.x - moveStart.x
        val dy = center.y - moveStart.y
        val xDom = abs(dx) >= abs(dy)
        val signX = if (dx >= 0f) 1 else -1
        val signY = if (dy >= 0f) 1 else -1

        val extra = elongPx.value  // px of extra length
        val scaleX: Float
        val scaleY: Float
        val originX: Float
        val originY: Float
        val topLeftX: Float
        val topLeftY: Float

        if (xDom) {
            // X → width = sizePx + extra; height stays constant (no squash)
            scaleX = 1f + extra / sizePx
            scaleY = 1f
            originY = 0.5f
            if (signX > 0) {
                // moving right → keep RIGHT edge fixed → stretch LEFT
                originX = 1f
                val rightEdge = center.x + sizePx / 2f
                topLeftX = rightEdge - sizePx
            } else {
                // moving left → keep LEFT edge fixed → stretch RIGHT
                originX = 0f
                val leftEdge = center.x - sizePx / 2f
                topLeftX = leftEdge
            }
            topLeftY = center.y - sizePx / 2f
        } else {
            // Y → height = sizePx + extra; width stays constant
            scaleY = 1f + extra / sizePx
            scaleX = 1f
            originX = 0.5f
            if (signY > 0) {
                // moving down → keep BOTTOM edge fixed → stretch UP
                originY = 1f
                val bottom = center.y + sizePx / 2f
                topLeftY = bottom - sizePx
            } else {
                // moving up → keep TOP edge fixed → stretch DOWN
                originY = 0f
                val top = center.y - sizePx / 2f
                topLeftY = top
            }
            topLeftX = center.x - sizePx / 2f
        }

        Box(
            modifier = Modifier
                .offset { IntOffset(topLeftX.toInt(), topLeftY.toInt()) }
                .size(objSize)
                .graphicsLayer {
                    transformOrigin = TransformOrigin(originX, originY)
                    rotationZ = 0f
                    shadowElevation = 0f
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
                .background(Color(0xFF1EB980))
        )
    }
}