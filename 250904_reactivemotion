// app/src/main/java/com/example/reactivemotion/MainActivity.kt
@file:Suppress("MagicNumber")

package com.example.reactivemotion

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.spring
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.atan2
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                Surface(Modifier.fillMaxSize(), color = Color(0xFF0E1116)) {
                    ReactiveMotionDemo(
                        modifier = Modifier.fillMaxSize(),
                        canvasSize = 360.dp,
                        objSize = 72.dp
                    )
                }
            }
        }
    }
}

@Composable
fun ReactiveMotionDemo(
    modifier: Modifier = Modifier,
    canvasSize: Dp = 320.dp,
    objSize: Dp = 72.dp
) {
    val density = LocalDensity.current
    val sizePx = with(density) { objSize.toPx() }

    // ---- FIX 1: Provide VectorConverter so type is inferable
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }

    // Separate springs for deformation
    val stretch = remember { Animatable(1f) }
    val angleDeg = remember { Animatable(0f) }

    // Specs with explicit type params (prevents “not enough info to infer”)
    val posSpring = spring<Offset>(
        dampingRatio = 0.95f,
        stiffness = Spring.StiffnessMediumLow
    )
    val deformSpring = spring<Float>(
        dampingRatio = 0.9f,
        stiffness = Spring.StiffnessMedium
    )

    // Tuning
    val VEL_FOR_MAX = with(density) { 1800f } // px/s at which stretch ~ caps
    val MAX_STRETCH = 1.35f
    val MIN_SQUASH = 1f / MAX_STRETCH
    val LPF = 0.75f // velocity low-pass

    // Velocity estimation from position deltas
    var last by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFiltered by remember { mutableStateOf(Offset.Zero) }

    // Observe position to drive deformation
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f // seconds
            val v = (p - last) * (1f / dt)
            vFiltered = vFiltered * LPF + v * (1f - LPF)

            val speed = hypot(vFiltered.x, vFiltered.y)
            val t = (speed / VEL_FOR_MAX).coerceIn(0f, 1f)
            val targetStretch = 1f + (MAX_STRETCH - 1f) * easeOutQuad(t)
            val targetAngle =
                if (speed > 1f) Math.toDegrees(atan2(vFiltered.y.toDouble(), vFiltered.x.toDouble())).toFloat()
                else angleDeg.value

            // ---- FIX 2: animateTo is suspend → call inside this coroutine
            stretch.animateTo(targetStretch, deformSpring)
            angleDeg.animateTo(targetAngle, deformSpring)

            last = p
            lastT = now
        }
    }

    val scope = rememberCoroutineScope()

    Box(
        modifier = modifier
            .size(canvasSize)
            .background(Color(0x00000000))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val target = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    // ---- FIX 2: animateTo is suspend → launch a coroutine
                    scope.launch {
                        pos.animateTo(target, animationSpec = posSpring, initialVelocity = vFiltered)
                    }
                }
            },
        contentAlignment = Alignment.TopStart
    ) {
        val scaleXRaw = stretch.value
        val scaleYRaw = 1f / scaleXRaw
        val scaleX = scaleXRaw.coerceIn(1f, MAX_STRETCH)
        val scaleY = max(MIN_SQUASH, min(1f, scaleYRaw))

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .graphicsLayer {
                    rotationZ = angleDeg.value
                    scaleX = scaleX
                    scaleY = scaleY
                    shadowElevation = 20f
                    shape = RectangleShape
                    clip = true
                }
                .clip(roundedBlob(stretch.value))
                .background(Color(0xFF6AD3FF))
        )
    }
}

private fun roundedBlob(stretch: Float) =
    androidx.compose.foundation.shape.RoundedCornerShape(percent = (min(100f, 70f / stretch)).toInt())

private fun easeOutQuad(t: Float) = 1f - (1f - t) * (1f - t)