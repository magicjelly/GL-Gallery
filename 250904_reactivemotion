// Significantly visible elongation: big stretch/squash + snappier accel detection.
// Axis-aware (Y → width↑, X → height↑). Full-screen tap. Box = 100.dp.

@file:Suppress("MagicNumber")

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.spring
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.pow

@Composable
fun ReactiveMotion_BigElongation() {
    val density = LocalDensity.current
    val objSize = 100.dp
    val sizePx = with(density) { objSize.toPx() }

    // Snappier travel so acceleration is noticeable, but still smooth.
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(
        dampingRatio = 0.9f,
        stiffness = Spring.StiffnessLow
    )

    // Deformation spring (smooth, quick)
    val stretch = remember { Animatable(1f) }
    val deformSpring = spring<Float>(
        dampingRatio = 1.05f,
        stiffness = Spring.StiffnessMedium
    )

    // >>> Big, obvious deformation caps <<<
    val MAX_STRETCH = 1.9f       // up to ~2x along main axis
    val MIN_SQUASH  = 0.52f      // ~0.5x on the other axis (area-ish preserved)
    // Sensitivity (larger effect, easier to trigger)
    val VLPF = 0.55f             // velocity filter
    val SLPF = 0.6f              // speed filter
    val DS_FOR_MAX = 350f        // ds/dt for near-max stretch (lower = more responsive)
    val AXIS_SHARPNESS = 2.2f    // >1 biases hard to dominant axis
    val VEL_EPS = 2f
    val CLOSE_EPS = with(density) { 16.dp.toPx() }

    // Kinematics state
    var lastP by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFilt by remember { mutableStateOf(Offset.Zero) }
    var speedFilt by remember { mutableStateOf(0f) }
    var lastSpeedFilt by remember { mutableStateOf(0f) }

    var latestTarget by remember { mutableStateOf(Offset.Zero) }
    var stretchTarget by remember { mutableStateOf(1f) }

    // Compute speed & ds/dt (acceleration of speed)
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f

            val v = (p - lastP) * (1f / dt)
            vFilt = vFilt * VLPF + v * (1f - VLPF)

            val speed = hypot(vFilt.x, vFilt.y)
            val sPrev = speedFilt
            speedFilt = sPrev * SLPF + speed * (1f - SLPF)

            val dsdt = (speedFilt - lastSpeedFilt) / dt // >0 accelerating

            // Map acceleration → stretch (big, obvious)
            val t = (dsdt / DS_FOR_MAX).coerceIn(0f, 1f)
            val accelStretch = 1f + (MAX_STRETCH - 1f) * (1f - (1f - t) * (1f - t))

            val remaining = (latestTarget - p).getDistance()
            val target =
                if (remaining < CLOSE_EPS) 1f
                else if (dsdt <= 0f) 1f
                else accelStretch

            if (kotlin.math.abs(target - stretchTarget) > 0.003f) stretchTarget = target

            lastSpeedFilt = speedFilt
            lastP = p; lastT = now
        }
    }

    // Follow stretch target smoothly
    LaunchedEffect(stretchTarget) {
        stretch.animateTo(stretchTarget, deformSpring)
    }

    val scope = rememberCoroutineScope()

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(tgt, animationSpec = posSpring, initialVelocity = vFilt)
                        stretch.animateTo(1f, deformSpring) // ensure rest at end
                    }
                }
            },
        contentAlignment = Alignment.TopStart
    ) {
        // Axis dominance with sharpness (soft-argmax)
        val ax = abs(vFilt.x); val ay = abs(vFilt.y)
        val axP = ax.pow(AXIS_SHARPNESS); val ayP = ay.pow(AXIS_SHARPNESS)
        val denom = (axP + ayP).coerceAtLeast(1e-3f)
        val wy = ayP / denom // →1 if Y dominates (widen), →0 if X dominates (heighten)

        val s = stretch.value.coerceIn(1f, MAX_STRETCH)
        val inv = (1f / s).coerceIn(MIN_SQUASH, 1f)

        val scaleX = lerp(inv, s, wy).coerceIn(MIN_SQUASH, MAX_STRETCH) // Y → width↑
        val scaleY = lerp(s, inv, wy).coerceIn(MIN_SQUASH, MAX_STRETCH) // X → height↑

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .background(Color(0xFF1EB980)) // high-contrast teal
                .graphicsLayer {
                    rotationZ = 0f
                    shadowElevation = 0f
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
        )
    }
}

private fun lerp(a: Float, b: Float, t: Float) = a + (b - a) * t