// Acceleration-driven elongation (accelerate → stretch, decelerate → return)
// Axis-aware: moving in Y → widen (scaleX↑), moving in X → heighten (scaleY↑)

@file:Suppress("MagicNumber")

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.VectorConverter
import androidx.compose.animation.core.spring
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min

@Composable
fun ReactiveMotion_AccelAware() {
    val density = LocalDensity.current
    val objSize = 100.dp
    val sizePx = with(density) { objSize.toPx() }

    // Slow travel; slight overdamp
    val pos = remember { Animatable(Offset.Zero, Offset.VectorConverter) }
    val posSpring = spring<Offset>(dampingRatio = 1.05f, stiffness = Spring.StiffnessVeryLow)

    // Smooth, quick deformation that can finish by arrival
    val stretch = remember { Animatable(1f) }
    val deformSpring = spring<Float>(dampingRatio = 1.05f, stiffness = Spring.StiffnessLow)

    val MAX_STRETCH = 1.25f
    val MIN_SQUASH  = 1f / MAX_STRETCH

    // Normalization constants
    val ACC_FOR_MAX = 3000f       // px/s^2 for near-max stretch
    val VEL_EPS = 10f             // px/s to avoid noisy direction at near-stop
    val CLOSE_EPS = with(density) { 18.dp.toPx() }

    // Filters
    val VLPF = 0.9f               // velocity low-pass
    val ALPF = 0.85f              // acceleration low-pass

    // State for kinematics
    var lastP by remember { mutableStateOf(Offset.Zero) }
    var lastT by remember { mutableStateOf(System.nanoTime()) }
    var vFilt by remember { mutableStateOf(Offset.Zero) }
    var vFiltPrev by remember { mutableStateOf(Offset.Zero) }
    var aFilt by remember { mutableStateOf(Offset.Zero) }

    // Targets
    var latestTarget by remember { mutableStateOf(Offset.Zero) }
    var stretchTarget by remember { mutableStateOf(1f) }

    // Observe position → update v, a, and stretch target based on ACCELERATION
    LaunchedEffect(Unit) {
        snapshotFlow { pos.value }.collect { p ->
            val now = System.nanoTime()
            val dt = (now - lastT).coerceAtLeast(1_000_000L) / 1e9f

            // velocity
            val v = (p - lastP) * (1f / dt)
            vFilt = vFilt * VLPF + v * (1f - VLPF)

            // acceleration (from filtered velocity)
            val aRaw = (vFilt - vFiltPrev) * (1f / dt)
            aFilt = aFilt * ALPF + aRaw * (1f - ALPF)

            // scalar accel along motion direction (+ accelerating, - decelerating)
            val speed = hypot(vFilt.x, vFilt.y)
            val vhat = if (speed > VEL_EPS) Offset(vFilt.x / speed, vFilt.y / speed) else Offset.Zero
            val scalarAccel = aFilt.x * vhat.x + aFilt.y * vhat.y

            // Map accel→stretch: only positive accel stretches; negative accel returns to 1
            val accelT = (scalarAccel / ACC_FOR_MAX).coerceIn(0f, 1f)
            val accelStretch = 1f + (MAX_STRETCH - 1f) * easeOutQuad(accelT)

            val remaining = (latestTarget - p).getDistance()
            val target =
                if (remaining < CLOSE_EPS) 1f            // finish exactly at arrival
                else if (scalarAccel <= 0f) 1f           // decelerating → return
                else accelStretch                        // accelerating → elongate

            if (kotlin.math.abs(target - stretchTarget) > 0.006f) stretchTarget = target

            vFiltPrev = vFilt
            lastP = p; lastT = now
        }
    }

    // Smoothly follow stretch target
    LaunchedEffect(stretchTarget) {
        stretch.animateTo(stretchTarget, deformSpring)
    }

    val scope = rememberCoroutineScope()

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF0E1116))
            .pointerInput(Unit) {
                detectTapGestures { tap ->
                    val pad = sizePx / 2f
                    val tgt = Offset(
                        tap.x.coerceIn(pad, size.width - pad),
                        tap.y.coerceIn(pad, size.height - pad)
                    )
                    latestTarget = tgt
                    scope.launch {
                        pos.animateTo(tgt, animationSpec = posSpring, initialVelocity = vFilt)
                        // safety pin
                        stretch.animateTo(1f, deformSpring)
                    }
                }
            },
        contentAlignment = Alignment.TopStart
    ) {
        // Axis-aware elongation (based on |vx| vs |vy|)
        val ax = abs(vFilt.x); val ay = abs(vFilt.y)
        val denom = (ax + ay).coerceAtLeast(1e-3f)
        val wy = ay / denom // 1 → Y-dominant ⇒ widen; 0 → X-dominant ⇒ heighten

        val s = stretch.value
        val inv = (1f / s).coerceAtLeast(MIN_SQUASH)

        val scaleX = lerp(inv, s, wy).coerceIn(MIN_SQUASH, MAX_STRETCH) // Y move → width↑
        val scaleY = lerp(s, inv, wy).coerceIn(MIN_SQUASH, MAX_STRETCH) // X move → height↑

        Box(
            modifier = Modifier
                .offset {
                    val o = pos.value
                    IntOffset((o.x - sizePx / 2f).toInt(), (o.y - sizePx / 2f).toInt())
                }
                .size(objSize)
                .background(Color(0xFF2196F3))
                .graphicsLayer {
                    rotationZ = 0f
                    shadowElevation = 0f
                    this.scaleX = scaleX
                    this.scaleY = scaleY
                }
        )
    }
}

private fun lerp(a: Float, b: Float, t: Float) = a + (b - a) * t
private fun easeOutQuad(t: Float) = 1f - (1f - t) * (1f - t)