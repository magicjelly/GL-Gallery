@Composable
private fun ReflectionOverlay(
    modifier: Modifier,
    dirX: Float,
    dirY: Float,
    intensity: Float,
    bandCurvature: Float = 0.18f,   // 0..0.35 : how much the band bows
    bandWidthFrac: Float = 0.22f,   // 0..0.4  : thickness of the sheen
    bandLengthFrac: Float = 1.35f   // 0.8..1.6: length of the sheen
) {
    val clamped = intensity.coerceIn(0f, 1f)
    Canvas(modifier = modifier) {
        val w = size.width
        val h = size.height
        val minD = size.minDimension
        val center = Offset(w * 0.5f, h * 0.5f)

        // Unit direction of the light sweep
        val nLen = max(1e-4f, sqrt(dirX * dirX + dirY * dirY))
        val axis = Offset(dirX / nLen, dirY / nLen)

        // --- 1) Bowed elliptical sheen band ---------------------------------
        // Build an elongated ellipse by scaling a circle, then rotate to axis.
        // We draw THREE slightly offset ellipses along a shallow quadratic curve
        // to get a natural "banana" highlight instead of a straight line.
        val bandAlpha = 0.55f * clamped
        val bandLen = hypot(w, h) * 0.5f * bandLengthFrac         // visual length
        val bandRad = minD * bandWidthFrac                        // thickness
        val pivot = center

        // Curved path offsets (quadratic y = kx^2 style along the axis-normal)
        val normal = Offset(-axis.y, axis.x)                      // 90° to axis
        val segs = listOf(-0.28f, 0f, 0.28f)                      // 3 lobes
        val weights = listOf(0.55f, 1.0f, 0.65f)                  // center brightest

        segs.forEachIndexed { i, t ->
            // Bow amount grows with |t|
            val bow = bandCurvature * t * t * bandLen
            val along = axis * (t * bandLen)
            val across = normal * bow
            val pos = pivot + along + across

            withTransform({
                translate(pos.x - pivot.x, pos.y - pivot.y)
                rotate(
                    degrees = Math.toDegrees(atan2(axis.y.toDouble(), axis.x.toDouble())).toFloat(),
                    pivot = Offset.Zero
                )
                // Scale circle -> ellipse (lengthwise vs thickness)
                scale(
                    sx = (bandLen / bandRad),
                    sy = 1f,
                    pivot = Offset.Zero
                )
            }) {
                // Draw a soft elliptical blob (from a radial gradient circle)
                val r = bandRad
                drawCircle(
                    brush = Brush.radialGradient(
                        colorStops = arrayOf(
                            0.0f to Color.White.copy(alpha = bandAlpha * 0.85f * weights[i]),
                            0.35f to Color.White.copy(alpha = bandAlpha * 0.55f * weights[i]),
                            0.7f to Color.White.copy(alpha = bandAlpha * 0.20f * weights[i]),
                            1.0f to Color.Transparent
                        ),
                        center = Offset.Zero,
                        radius = r
                    ),
                    radius = r
                )
            }
        }

        // Optional very soft crossfade to remove any band edges (subtle fog)
        drawRect(
            brush = Brush.radialGradient(
                colors = listOf(
                    Color.White.copy(alpha = 0.06f * clamped),
                    Color.Transparent
                ),
                center = center,
                radius = size.maxDimension * 0.9f
            ),
            size = size,
            blendMode = BlendMode.Screen
        )

        // --- 2) Specular hotspot (kept, slightly tighter) -------------------
        val hotspotCenter = center + axis * (minD * 0.06f)
        val hotspotRadius = minD * 0.18f
        val hotspotAlpha = 0.40f * clamped
        drawCircle(
            brush = Brush.radialGradient(
                colors = listOf(
                    Color.White.copy(alpha = hotspotAlpha),
                    Color.Transparent
                ),
                center = hotspotCenter,
                radius = hotspotRadius
            ),
            radius = hotspotRadius,
            center = hotspotCenter
        )

        // --- 3) Fresnel rim (edge brightening opposite light) ---------------
        // Brighter on the edge facing the light direction; very subtle.
        val sweepCenter = center
        drawCircle(
            brush = Brush.sweepGradient(
                colors = listOf(
                    // Start opposite the light (dim) → towards light (bright) → wrap
                    Color.White.copy(alpha = 0.00f),
                    Color.White.copy(alpha = 0.10f * clamped),
                    Color.White.copy(alpha = 0.00f)
                ),
                center = sweepCenter
            ),
            radius = size.maxDimension * 0.54f,
            style = androidx.compose.ui.graphics.drawscope.Stroke(
                width = minD * 0.012f
            ),
            blendMode = BlendMode.Screen
        )

        // --- 4) Subtle vignette to ground edges ------------------------------
        drawRect(
            brush = Brush.radialGradient(
                colors = listOf(
                    Color.Transparent,
                    Color.Black.copy(alpha = 0.12f)
                ),
                center = center,
                radius = size.maxDimension * 0.95f
            ),
            size = size,
            blendMode = BlendMode.Multiply
        )
    }
}