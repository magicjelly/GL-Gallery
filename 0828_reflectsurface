@file:Suppress("FunctionName")

package your.package.name

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.Spring
import androidx.compose.animation.core.spring
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.matchParentSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PaintingStyle
import androidx.compose.ui.graphics.Painter
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.drawscope.withTransform
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.consume
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.sqrt

/**
 * Netflix-like tilting card with natural reflection and drag control.
 * Drag on the tile to tilt; releasing springs it back to rest.
 */
@Composable
fun TiltReflectionTile(
    modifier: Modifier = Modifier,
    imagePainter: Painter,
    cornerRadius: Dp = 16.dp,
    maxTiltDeg: Float = 18f,
    parallaxPx: Float = 18f,
    specularStrength: Float = 0.55f,
    baseElevationDp: Dp = 18.dp,
) {
    val scope = rememberCoroutineScope()
    val density = LocalDensity.current
    val shape = remember(cornerRadius) { RoundedCornerShape(cornerRadius) }

    // Live drag state (not suspend)
    var rotX by remember { mutableFloatStateOf(0f) }
    var rotY by remember { mutableFloatStateOf(0f) }

    // Spring-back animators used only on release
    val animX = remember { Animatable(0f) }
    val animY = remember { Animatable(0f) }

    // Sensitivity (deg per px) — tweak to taste
    val pxToDeg = 0.08f

    // Drag → rotation mapping; on release, spring back using Animatable
    val pointer = Modifier.pointerInput(Unit) {
        detectDragGestures(
            onDragStart = {
                // If a spring is running (coming back), stop it and resume from current display value
                if (animX.isRunning || animY.isRunning) {
                    scope.launch {
                        animX.stop()
                        animY.stop()
                    }
                }
            },
            onDragEnd = {
                scope.launch {
                    // Start springs from current rotX/rotY back to zero
                    animX.snapTo(rotX)
                    animY.snapTo(rotY)
                    val spec = spring<Float>(
                        stiffness = Spring.StiffnessLow,
                        dampingRatio = 0.72f
                    )
                    // run both sequentially or in parallel – sequential keeps it simple
                    animX.animateTo(0f, spec)
                    animY.animateTo(0f, spec)
                }
            },
            onDragCancel = {
                scope.launch {
                    animX.snapTo(rotX)
                    animY.snapTo(rotY)
                    val spec = spring<Float>(
                        stiffness = Spring.StiffnessLow,
                        dampingRatio = 0.72f
                    )
                    animX.animateTo(0f, spec)
                    animY.animateTo(0f, spec)
                }
            }
        ) { change, dragAmount ->
            change.consume()
            val (dx, dy) = dragAmount
            rotX = (rotX + dy * pxToDeg).coerceIn(-maxTiltDeg, maxTiltDeg) // vertical drag tilts forward/back
            rotY = (rotY - dx * pxToDeg).coerceIn(-maxTiltDeg, maxTiltDeg) // horizontal drag tilts left/right
        }
    }

    // Decide what to draw: during spring-back, use anim values; else the live drag values
    val drawRotX = if (animX.isRunning || animY.isRunning) animX.value else rotX
    val drawRotY = if (animX.isRunning || animY.isRunning) animY.value else rotY

    // Camera distance: larger reduces perspective exaggeration
    val cameraDistancePx = with(density) { 16.dp.toPx() }

    // Elevation grows a bit with tilt to fake deepening contact shadow
    val tiltMag = sqrt(drawRotX * drawRotX + drawRotY * drawRotY)
    val dynamicElevation = baseElevationDp + (tiltMag / maxTiltDeg * 8f).dp

    // Parallax shift of the image (opposite the rotation for depth feel)
    val imgTx = (-drawRotY / maxTiltDeg) * parallaxPx
    val imgTy = (drawRotX / maxTiltDeg) * parallaxPx

    // Reflection parameters from tilt
    val nx = drawRotY / maxTiltDeg           // left/right normal component [-1..1]
    val ny = -drawRotX / maxTiltDeg          // up/down normal component [-1..1]
    val normalLen = max(1e-4f, sqrt(nx * nx + ny * ny))
    val dirX = nx / normalLen
    val dirY = ny / normalLen
    val dynamicSpecular = (0.25f + 0.75f * (ny * 0.5f + 0.5f)) * specularStrength

    Box(
        modifier
            .graphicsLayer {
                rotationX = drawRotX
                rotationY = drawRotY
                cameraDistance = cameraDistancePx
                shadowElevation = with(density) { dynamicElevation.toPx() }
                shape = shape
                clip = true
            }
            .then(pointer)
    ) {
        // Poster image with subtle parallax and overscale
        Image(
            painter = imagePainter,
            contentDescription = null,
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .matchParentSize()
                .graphicsLayer {
                    translationX = imgTx
                    translationY = imgTy
                    scaleX = 1.03f
                    scaleY = 1.03f
                }
        )

        // Moving light reflection overlay
        ReflectionOverlay(
            modifier = Modifier.matchParentSize(),
            dirX = dirX,
            dirY = dirY,
            intensity = dynamicSpecular
        )
    }
}

/**
 * Natural-looking moving reflection:
 *  - a slim linear "sheen" band aligned to (dirX, dirY)
 *  - a soft radial hotspot near the band
 *  - a subtle vignette to ground edges while tilting
 */
@Composable
private fun ReflectionOverlay(
    modifier: Modifier,
    dirX: Float,
    dirY: Float,
    intensity: Float
) {
    val clamped = intensity.coerceIn(0f, 1f)
    androidx.compose.foundation.Canvas(modifier = modifier) {
        val w = size.width
        val h = size.height
        val center = Offset(w * 0.5f, h * 0.5f)

        // Axis for the sweeping band
        val axis = Offset(dirX, dirY)
        val halfExtent = hypot(w, h) * 0.7f
        val start = center - axis * halfExtent
        val end = center + axis * halfExtent

        // Sheen band
        val bandAlpha = 0.65f * clamped
        val bandColors = listOf(
            Color.White.copy(alpha = 0f),
            Color.White.copy(alpha = bandAlpha * 0.15f),
            Color.White.copy(alpha = bandAlpha),
            Color.White.copy(alpha = bandAlpha * 0.15f),
            Color.White.copy(alpha = 0f),
        )
        val bandStops = listOf(0.32f, 0.45f, 0.5f, 0.55f, 0.68f)

        drawRect(
            brush = Brush.linearGradient(
                colors = bandColors,
                start = start,
                end = end
            ),
            size = size,
            alpha = 1f
        )

        // Specular hotspot near the band center
        val hotspotCenter = center + axis * (size.minDimension * 0.05f)
        val hotspotRadius = size.minDimension * 0.22f
        val hotspotAlpha = 0.45f * clamped

        drawCircle(
            brush = Brush.radialGradient(
                colors = listOf(
                    Color.White.copy(alpha = hotspotAlpha),
                    Color.White.copy(alpha = 0f)
                ),
                center = hotspotCenter,
                radius = hotspotRadius
            ),
            radius = hotspotRadius,
            center = hotspotCenter
        )

        // Soft vignette to keep edges grounded
        val vignetteAlpha = 0.12f
        drawRect(
            brush = Brush.radialGradient(
                colors = listOf(
                    Color.Black.copy(alpha = 0f),
                    Color.Black.copy(alpha = vignetteAlpha)
                ),
                center = center,
                radius = size.maxDimension * 0.9f
            ),
            size = size,
            blendMode = BlendMode.Multiply
        )
    }
}

@Preview(showBackground = true)
@Composable
private fun TiltReflectionTilePreview() {
    MaterialTheme {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            contentAlignment = Alignment.Center
        ) {
            TiltReflectionTile(
                modifier = Modifier.size(width = 240.dp, height = 360.dp),
                imagePainter = painterResource(id = android.R.drawable.ic_menu_gallery)
            )
        }
    }
}