
uniform shader iChannel0;
uniform shader iChannel1;
uniform float iTime;
uniform float iMouseX;
uniform float iMouseZ;
uniform vec2 iResolution;

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;

    // Mouse-controlled transition progress (0 to 1)
    float progress = iMouseZ > 0.0 
        ? clamp(iMouseX / iResolution.x, 0.0, 1.0) 
        : 0.0;

    // Eased progress for smoother visual feel
    float eased = progress < 0.5 
        ? 2.0 * progress * progress 
        : -1.0 + (4.0 - 2.0 * progress) * progress;

    // Strength of distortion peaks at middle, 0 at start and end
    float distortionStrength = sin(eased * 3.1415); // 0 → 1 → 0

    // Distortion offset: small wave pattern
    float2 offset = float2(
        sin(uv.y * 40.0 + iTime * 5.0) * 0.01,
        cos(uv.x * 40.0 + iTime * 5.0) * 0.01
    ) * distortionStrength;

    // Apply offset directionally to both images
    float2 uvA = uv + offset * (1.0 - eased);
    float2 uvB = uv - offset * eased;

    // Sample both images
    half4 colorA = iChannel0.eval(uvA * iResolution);
    half4 colorB = iChannel1.eval(uvB * iResolution);

    // Crossfade based on eased progress
    return mix(colorA, colorB, eased);
}




@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderTransitionCanvas(
    @DrawableRes imageA: Int,
    @DrawableRes imageB: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val imageBitmapA = ImageBitmap.imageResource(imageA)
    val imageBitmapB = ImageBitmap.imageResource(imageB)

    val shaderCode = remember {
        context.resources.openRawResource(R.raw.transition_shader).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    val canvasWidthPx = with(density) { canvasWidthDp.toPx() }
    val canvasHeightPx = with(density) { canvasHeightDp.toPx() }

    Canvas(
        modifier = modifier
            .size(canvasWidthDp, canvasHeightDp)
            .pointerInput(Unit) {
                detectDragGestures { change, _ ->
                    dragX.floatValue = change.position.x
                }
            }
    ) {
        val canvasSize = size

        // Calculate image scale and offset for aspect-fit
        val scaleA = minOf(canvasSize.width / imageBitmapA.width, canvasSize.height / imageBitmapA.height)
        val scaleB = minOf(canvasSize.width / imageBitmapB.width, canvasSize.height / imageBitmapB.height)

        val imageShaderA = ImageShader(
            imageBitmapA,
            TileMode.Clamp,
            TileMode.Clamp,
            matrix = Matrix().apply {
                reset()
                preScale(scaleA, scaleA)
            }
        )
        val imageShaderB = ImageShader(
            imageBitmapB,
            TileMode.Clamp,
            TileMode.Clamp,
            matrix = Matrix().apply {
                reset()
                preScale(scaleB, scaleB)
            }
        )

        runtimeShader.setInputShader("iChannel0", imageShaderA)
        runtimeShader.setInputShader("iChannel1", imageShaderB)
        runtimeShader.setFloatUniform("iResolution", canvasSize.width, canvasSize.height)
        runtimeShader.setFloatUniform("iTime", time.value)
        runtimeShader.setFloatUniform("iMouseX", dragX.floatValue)
        runtimeShader.setFloatUniform("iMouseZ", 1f)

        drawRect(brush = ShaderBrush(runtimeShader))
    }
}
 
