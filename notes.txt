@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderTransitionCanvas(
    @DrawableRes imageA: Int,
    @DrawableRes imageB: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val imageBitmapA = ImageBitmap.imageResource(imageA)
    val imageBitmapB = ImageBitmap.imageResource(imageB)

    val shaderCode = remember {
        context.resources.openRawResource(R.raw.transition_shader).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    Canvas(
        modifier = modifier
            .size(canvasWidthDp, canvasHeightDp)
            .pointerInput(Unit) {
                detectDragGestures { change, _ ->
                    dragX.floatValue = change.position.x
                }
            }
    ) {
        val canvasWidth = size.width
        val canvasHeight = size.height

        // calculate scale to fit image into canvas
        val scaleA = minOf(canvasWidth / imageBitmapA.width, canvasHeight / imageBitmapA.height)
        val scaleB = minOf(canvasWidth / imageBitmapB.width, canvasHeight / imageBitmapB.height)

        val scaledWidth = imageBitmapA.width * scaleA
        val scaledHeight = imageBitmapA.height * scaleA
        val offsetX = (canvasWidth - scaledWidth) / 2f
        val offsetY = (canvasHeight - scaledHeight) / 2f

        val shaderA = ImageShader(imageBitmapA, TileMode.Clamp, TileMode.Clamp)
        val shaderB = ImageShader(imageBitmapB, TileMode.Clamp, TileMode.Clamp)

        runtimeShader.setInputShader("iChannel0", shaderA)
        runtimeShader.setInputShader("iChannel1", shaderB)
        runtimeShader.setFloatUniform("iResolution", canvasWidth, canvasHeight)
        runtimeShader.setFloatUniform("iTime", time.value)
        runtimeShader.setFloatUniform("iMouseX", dragX.floatValue)
        runtimeShader.setFloatUniform("iMouseZ", 1f)

        // scale + center the shader content
        withTransform({
            translate(offsetX, offsetY)
            scale(scaleA, scaleA)
        }) {
            drawRect(
                brush = ShaderBrush(runtimeShader),
                size = Size(imageBitmapA.width.toFloat(), imageBitmapA.height.toFloat())
            )
        }
    }
}