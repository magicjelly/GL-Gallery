@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderTransitionCanvas(
    @DrawableRes imageA: Int,
    @DrawableRes imageB: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val imageBitmapA = ImageBitmap.imageResource(imageA)
    val imageBitmapB = ImageBitmap.imageResource(imageB)

    val shaderCode = remember {
        context.resources.openRawResource(R.raw.transition_shader).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    val canvasWidthPx = with(density) { canvasWidthDp.toPx() }
    val canvasHeightPx = with(density) { canvasHeightDp.toPx() }

    Canvas(
        modifier = modifier
            .size(canvasWidthDp, canvasHeightDp)
            .pointerInput(Unit) {
                detectDragGestures { change, _ ->
                    dragX.floatValue = change.position.x
                }
            }
    ) {
        val canvasSize = size

        val imageWidth = imageBitmapA.width.toFloat()
        val imageHeight = imageBitmapA.height.toFloat()

        val scale = minOf(canvasSize.width / imageWidth, canvasSize.height / imageHeight)

        val drawWidth = imageWidth * scale
        val drawHeight = imageHeight * scale

        val offsetX = (canvasSize.width - drawWidth) / 2f
        val offsetY = (canvasSize.height - drawHeight) / 2f

        val shaderA = ImageShader(imageBitmapA, TileMode.Clamp, TileMode.Clamp)
        val shaderB = ImageShader(imageBitmapB, TileMode.Clamp, TileMode.Clamp)

        // Set resolution to match scaled image (not full canvas)
        runtimeShader.setFloatUniform("iResolution", drawWidth, drawHeight)
        runtimeShader.setFloatUniform("iTime", time.value)
        runtimeShader.setFloatUniform("iMouseX", (dragX.floatValue - offsetX).coerceIn(0f, drawWidth))
        runtimeShader.setFloatUniform("iMouseZ", 1f)
        runtimeShader.setInputShader("iChannel0", shaderA)
        runtimeShader.setInputShader("iChannel1", shaderB)

        withTransform({
            translate(offsetX, offsetY)
            scale(scale, scale)
        }) {
            drawRect(
                brush = ShaderBrush(runtimeShader),
                size = Size(imageWidth, imageHeight)
            )
        }
    }
}