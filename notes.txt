@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderCanvasTemplate(
    imageList: List<ImageBitmap>,
    @RawRes shaderResId: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp,
    onPlayReady: (suspend (duration: Int, easing: Easing) -> Unit) -> Unit
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val shaderCode = remember {
        context.resources.openRawResource(shaderResId).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    var isPlaying by remember { mutableStateOf(false) }
    val animatedProgress = remember { Animatable(0f) }

    var playTrigger by remember { mutableStateOf(0) }
    var playConfig by remember { mutableStateOf(Pair(2000, LinearEasing)) }

    var currentIndex by remember { mutableIntStateOf(0) }

    val canvasWidthPx = with(density) { canvasWidthDp.toPx() }
    val canvasHeightPx = with(density) { canvasHeightDp.toPx() }

    val imageA = imageList[currentIndex % imageList.size]
    val imageB = imageList[(currentIndex + 1) % imageList.size]

    val scaledImageA = remember(imageA, canvasWidthPx, canvasHeightPx) {
        imageA.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }
    val scaledImageB = remember(imageB, canvasWidthPx, canvasHeightPx) {
        imageB.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }

    val progressX = if (isPlaying) {
        animatedProgress.value * canvasWidthPx
    } else {
        dragX.floatValue
    }

    // Expose play() to parent
    LaunchedEffect(Unit) {
        onPlayReady { duration, easing ->
            dragX.floatValue = 0f
            playConfig = duration to easing
            playTrigger++
        }
    }

    // Animate shader transition
    LaunchedEffect(playTrigger) {
        if (playTrigger > 0) {
            isPlaying = true
            animatedProgress.snapTo(0f)
            animatedProgress.animateTo(
                targetValue = 1f,
                animationSpec = tween(playConfig.first, easing = playConfig.second)
            )
            isPlaying = false
            currentIndex = (currentIndex + 1) % imageList.size
        }
    }

    // Animate time
    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Canvas(
            modifier = Modifier
                .size(canvasWidthDp, canvasHeightDp)
                .pointerInput(isPlaying) {
                    if (!isPlaying) {
                        detectDragGestures { change, _ ->
                            dragX.floatValue = change.position.x
                        }
                    }
                }
        ) {
            val shaderA = ImageShader(scaledImageA, TileMode.Clamp, TileMode.Clamp)
            val shaderB = ImageShader(scaledImageB, TileMode.Clamp, TileMode.Clamp)

            runtimeShader.setInputShader("iChannel0", shaderA)
            runtimeShader.setInputShader("iChannel1", shaderB)
            runtimeShader.setFloatUniform("iResolution", size.width, size.height)
            runtimeShader.setFloatUniform("iTime", time.value)
            runtimeShader.setFloatUniform("iMouseX", progressX.coerceIn(0f, size.width))
            runtimeShader.setFloatUniform("iMouseZ", 1f)

            drawRect(brush = ShaderBrush(runtimeShader))
        }
    }
}

fun Bitmap.scaleToFit(maxWidth: Int, maxHeight: Int): Bitmap {
    val scale = minOf(maxWidth / width.toFloat(), maxHeight / height.toFloat())
    val newWidth = (width * scale).toInt()
    val newHeight = (height * scale).toInt()
    return Bitmap.createScaledBitmap(this, newWidth, newHeight, true)
}


// how to use
var playFn: (suspend (Int, Easing) -> Unit)? by remember { mutableStateOf(null) }

ShaderCanvasTemplate(
    imageList = listOf(
        ImageBitmap.imageResource(R.drawable.image1),
        ImageBitmap.imageResource(R.drawable.image2),
        ImageBitmap.imageResource(R.drawable.image3)
    ),
    shaderResId = R.raw.transition_shader,
    onPlayReady = { playFn = it }
)

Button(onClick = {
    playFn?.invoke(1500, FastOutSlowInEasing)
}) {
    Text("Next Transition")
}