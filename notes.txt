@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderTransitionCanvas(
    @DrawableRes imageA: Int,
    @DrawableRes imageB: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val shaderCode = remember {
        context.resources.openRawResource(R.raw.transition_shader).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val imageBitmapA = ImageBitmap.imageResource(imageA)
    val imageBitmapB = ImageBitmap.imageResource(imageB)

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    val canvasWidthPx = with(density) { canvasWidthDp.toPx() }
    val canvasHeightPx = with(density) { canvasHeightDp.toPx() }

    // Pre-scale image to match canvas while keeping aspect ratio
    val scaledImageA = remember(canvasWidthPx, canvasHeightPx) {
        imageBitmapA.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }
    val scaledImageB = remember(canvasWidthPx, canvasHeightPx) {
        imageBitmapB.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }

    Canvas(
        modifier = modifier
            .size(canvasWidthDp, canvasHeightDp)
            .pointerInput(Unit) {
                detectDragGestures { change, _ ->
                    dragX.floatValue = change.position.x
                }
            }
    ) {
        val shaderA = ImageShader(scaledImageA, TileMode.Clamp, TileMode.Clamp)
        val shaderB = ImageShader(scaledImageB, TileMode.Clamp, TileMode.Clamp)

        runtimeShader.setInputShader("iChannel0", shaderA)
        runtimeShader.setInputShader("iChannel1", shaderB)
        runtimeShader.setFloatUniform("iResolution", size.width, size.height)
        runtimeShader.setFloatUniform("iTime", time.value)
        runtimeShader.setFloatUniform("iMouseX", dragX.floatValue)
        runtimeShader.setFloatUniform("iMouseZ", 1f)

        drawRect(brush = ShaderBrush(runtimeShader))
    }
}

fun Bitmap.scaleToFit(maxWidth: Int, maxHeight: Int): Bitmap {
    val scale = minOf(maxWidth / width.toFloat(), maxHeight / height.toFloat())
    val newWidth = (width * scale).toInt()
    val newHeight = (height * scale).toInt()
    return Bitmap.createScaledBitmap(this, newWidth, newHeight, true)
}