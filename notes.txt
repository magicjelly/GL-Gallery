@RequiresApi(Build.VERSION_CODES.TIRAMISU)
@Composable
fun ShaderTransitionCanvas(
    @DrawableRes imageA: Int,
    @DrawableRes imageB: Int,
    modifier: Modifier = Modifier,
    canvasWidthDp: Dp = 300.dp,
    canvasHeightDp: Dp = 300.dp
) {
    val context = LocalContext.current
    val density = LocalDensity.current

    val shaderCode = remember {
        context.resources.openRawResource(R.raw.transition_shader).bufferedReader().use { it.readText() }
    }
    val runtimeShader = remember { RuntimeShader(shaderCode) }

    val imageBitmapA = ImageBitmap.imageResource(imageA)
    val imageBitmapB = ImageBitmap.imageResource(imageB)

    val time = remember { Animatable(0f) }
    val dragX = remember { mutableFloatStateOf(0f) }

    var isPlaying by remember { mutableStateOf(false) }
    val animatedProgress = remember { Animatable(0f) }

    // play trigger
    fun play(durationMillis: Int = 2000, easing: Easing = LinearEasing) {
        isPlaying = true
        dragX.floatValue = 0f
        LaunchedEffect(Unit) {
            animatedProgress.snapTo(0f)
            animatedProgress.animateTo(1f, animationSpec = tween(durationMillis, easing = easing))
            isPlaying = false
        }
    }

    // Animate time
    LaunchedEffect(Unit) {
        while (true) {
            time.snapTo(time.value + 0.016f)
            delay(16)
        }
    }

    val canvasWidthPx = with(density) { canvasWidthDp.toPx() }
    val canvasHeightPx = with(density) { canvasHeightDp.toPx() }

    val scaledImageA = remember(canvasWidthPx, canvasHeightPx) {
        imageBitmapA.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }
    val scaledImageB = remember(canvasWidthPx, canvasHeightPx) {
        imageBitmapB.asAndroidBitmap().scaleToFit(canvasWidthPx.toInt(), canvasHeightPx.toInt()).asImageBitmap()
    }

    val progressX = if (isPlaying) {
        animatedProgress.value * canvasWidthPx
    } else {
        dragX.floatValue
    }

    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Canvas(
            modifier = Modifier
                .size(canvasWidthDp, canvasHeightDp)
                .pointerInput(isPlaying) {
                    if (!isPlaying) {
                        detectDragGestures { change, _ ->
                            dragX.floatValue = change.position.x
                        }
                    }
                }
        ) {
            val shaderA = ImageShader(scaledImageA, TileMode.Clamp, TileMode.Clamp)
            val shaderB = ImageShader(scaledImageB, TileMode.Clamp, TileMode.Clamp)

            runtimeShader.setInputShader("iChannel0", shaderA)
            runtimeShader.setInputShader("iChannel1", shaderB)
            runtimeShader.setFloatUniform("iResolution", size.width, size.height)
            runtimeShader.setFloatUniform("iTime", time.value)
            runtimeShader.setFloatUniform("iMouseX", progressX.coerceIn(0f, size.width))
            runtimeShader.setFloatUniform("iMouseZ", 1f)

            drawRect(brush = ShaderBrush(runtimeShader))
        }

        Button(
            onClick = { play(2000, FastOutSlowInEasing) },
            modifier = Modifier.align(Alignment.BottomCenter).padding(16.dp)
        ) {
            Text("Play Effect")
        }
    }
}