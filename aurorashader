uniform shader iChannel0;
uniform shader iChannel1;
uniform float2 iResolution;
uniform float iTime;
uniform float iMouseX;
uniform float iMouseZ;

// Hash for pseudo-randomness
float hash(float2 p) {
    return fract(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// Smooth noise with higher frequency
float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// High-res layered aurora noise
float auroraField(float2 uv, float time) {
    float acc = 0.0;
    float scale = 1.0;
    for (int i = 0; i < 4; i++) {
        float2 nUV = uv * scale + float2(0.0, time * 0.03 * scale);
        acc += (noise(nUV) - 0.5) * (0.5 / scale);
        scale *= 2.0;
    }
    return acc;
}

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;
    uv = clamp(uv, 0.0, 1.0);

    half4 img0 = iChannel0.eval(uv);
    half4 img1 = iChannel1.eval(uv);
    float progress = clamp(iMouseX / iResolution.x, 0.0, 1.0);

    // Aurora overlay
    float aura = auroraField(uv * 5.0, iTime);
    float intensity = smoothstep(0.0, 1.0, abs(aura)) * 1.2;
    float2 offset = float2(0.0, aura * 0.02);
    float2 auroraUV = clamp(uv + offset, 0.0, 1.0);
    half4 auroraColor = iChannel1.eval(auroraUV);
    auroraColor.rgb *= intensity;

    // Static-to-static transition with aurora overlay
    half4 transition = mix(img0, img1, progress);
    half4 result = transition + auroraColor * (1.0 - abs(progress - 0.5) * 2.0);

    return result;
}