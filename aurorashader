uniform shader iChannel0;
uniform shader iChannel1;
uniform float2 iResolution;
uniform float iTime;
uniform float iMouseX;
uniform float iMouseZ;

// Random hash
float hash(float2 p) {
    return fract(sin(dot(p, float2(127.1, 311.7))) * 43758.5453);
}

// 2D noise
float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Layered noise-based aurora pattern
float aurora(float2 uv, float time) {
    float accum = 0.0;
    float freq = 1.0;
    float amp = 1.0;
    for (int i = 0; i < 5; i++) {
        float2 nUV = uv * freq + float2(0.0, time * 0.05 * freq);
        accum += (noise(nUV) - 0.5) * amp;
        freq *= 2.0;
        amp *= 0.5;
    }
    return accum;
}

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;
    uv = clamp(uv, 0.0, 1.0);

    half4 img0 = iChannel0.eval(uv);
    half4 img1 = iChannel1.eval(uv);

    float progress = clamp(iMouseX / iResolution.x, 0.0, 1.0);

    // Aurora field
    float aura = aurora(uv * 3.0, iTime);
    float depth = smoothstep(0.0, 1.0, abs(aura));
    float glow = smoothstep(0.0, 0.5, 0.4 + aura * 0.6);

    // Shift UV slightly for spatial movement
    float2 flow = float2(0.0, aura * 0.04);
    float2 auroraUV = clamp(uv + flow, 0.0, 1.0);

    // Use iChannel1 as color source for aurora
    half4 auroraColor = iChannel1.eval(auroraUV);
    auroraColor.rgb *= glow * depth * 1.5;

    // Mix image transition and aurora overlay
    half4 baseMix = mix(img0, img1, progress);
    half4 finalColor = baseMix + auroraColor;

    return finalColor;
}