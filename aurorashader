uniform shader iChannel0;
uniform shader iChannel1;
uniform float2 iResolution;
uniform float iTime;
uniform float iMouseX;
uniform float iMouseZ;

// High quality hash
float hash(float2 p) {
    return fract(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123);
}

// Smooth interpolated noise
float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Layered noise for spatial aurora
float auroraField(float2 uv, float time) {
    float sum = 0.0;
    float scale = 2.0;
    float weight = 0.5;

    for (int i = 0; i < 4; i++) {
        float2 pos = uv * scale + float2(0.0, time * 0.02 * scale);
        sum += (noise(pos) - 0.5) * weight;
        scale *= 2.0;
        weight *= 0.5;
    }
    return sum;
}

half4 main(float2 fragCoord) {
    float2 uv = fragCoord / iResolution;
    uv = clamp(uv, 0.0, 1.0);

    float progress = clamp(iMouseX / iResolution.x, 0.0, 1.0);

    // Sample base images
    half4 img0 = iChannel0.eval(uv);
    half4 img1 = iChannel1.eval(uv);

    // Aurora strength fades in and out during mid-transition only
    float auraBlend = smoothstep(0.15, 0.5, progress) * smoothstep(0.85, 0.5, progress);

    // Aurora displacement and glow
    float aurora = auroraField(uv * 6.0, iTime);
    float2 displaceUV = clamp(uv + float2(0.0, aurora * 0.03), 0.0, 1.0);
    half4 auroraColor = iChannel1.eval(displaceUV);
    auroraColor.rgb *= smoothstep(0.0, 1.0, abs(aurora)) * 1.4;

    // Blend images with aurora overlay only in mid-transition
    half4 blend = mix(img0, img1, progress);
    half4 result = blend + auroraColor * auraBlend;

    return result;
}
