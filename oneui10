@file:Suppress("UnusedImport")

package com.example.magnetism

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.spring
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.isActive
import kotlin.math.*

/* ──────────────────────────────────────────────────────────────────────────────
   DATA + SIM
   ──────────────────────────────────────────────────────────────────────────── */

data class Magnet(
    val id: Int,
    val basePos: Offset,           // grid slot (doesn't change)
    var sigma: Float,              // current spread (px)
    val sigmaIdle: Float,
    val sigmaPressed: Float
)

/** Overlap (Gaussian) based force model using live positions each frame. */
class MagnetSim(
    private val count: Int,
    private val kAttr: Float = 28f,
    private val kRep: Float = 34f,
    private val fMax: Float = 1800f
) {
    private val baselineOverlap = HashMap<Long, Float>()

    fun initBaseline(basePositions: List<Offset>, sigmas: List<Float>) {
        baselineOverlap.clear()
        for (i in 0 until count) for (j in i + 1 until count) {
            baselineOverlap[key(i, j)] = overlap(basePositions[i], sigmas[i], basePositions[j], sigmas[j])
        }
    }

    /** positions = live animated positions; sigmas = current spreads */
    fun step(
        positions: List<Offset>,
        sigmas: List<Float>,
        anchoredIds: Set<Int> = emptySet()
    ): Map<Int, Offset> {
        val out = HashMap<Int, Offset>(count)
        for (i in 0 until count) {
            if (i in anchoredIds) { out[i] = Offset.Zero; continue }
            val pi = positions[i]; val si = sigmas[i]
            var fx = 0f; var fy = 0f
            for (j in 0 until count) if (i != j) {
                val pj = positions[j]; val sj = sigmas[j]
                val dx = pj.x - pi.x; val dy = pj.y - pi.y
                val d = hypot(dx, dy).coerceAtLeast(1e-3f)
                if (d > 3f * max(si, sj)) continue

                val oNow = overlap(pi, si, pj, sj)
                val oBase = baselineOverlap[key(i, j)] ?: continue
                val dO = oBase - oNow // >0 attract; <0 repel

                val k = if (dO > 0f) kAttr else kRep
                val f = (k * abs(dO)).coerceAtMost(fMax)
                val s = if (dO >= 0f) +1f else -1f
                fx += (dx / d) * f * s
                fy += (dy / d) * f * s
            }
            out[i] = Offset(fx, fy)
        }
        return out
    }

    private fun overlap(pi: Offset, si: Float, pj: Offset, sj: Float): Float {
        val dx = pi.x - pj.x; val dy = pi.y - pj.y
        val d2 = dx*dx + dy*dy
        val s2 = si*si + sj*sj
        return kotlin.math.exp(-d2 / (2f * s2))
    }

    private fun key(i: Int, j: Int): Long {
        val a = min(i, j); val b = max(i, j)
        return (a.toLong() shl 32) or b.toLong()
    }
}

/* ──────────────────────────────────────────────────────────────────────────────
   DEBUG UI
   ──────────────────────────────────────────────────────────────────────────── */

enum class FieldViewMode { Combined, PerMagnet }

private val magnetColors = listOf(
    Color(0xFF5C9DFF), Color(0xFFFF7A7A), Color(0xFFFFC85C),
    Color(0xFF74E0A6), Color(0xFFB78CFF), Color(0xFFFFA9DD),
    Color(0xFF66E3FF), Color(0xFFA0F07A), Color(0xFFB0C7D1)
)

@Composable
fun MagneticDebugToggle(show: Boolean, onToggle: (Boolean) -> Unit) {
    Row(
        Modifier
            .padding(12.dp)
            .clip(RoundedCornerShape(12.dp))
            .background(Color(0x6618181C))
            .padding(horizontal = 12.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text("Field lines", color = Color.White)
        Spacer(Modifier.width(8.dp))
        Switch(checked = show, onCheckedChange = onToggle)
    }
}

@Composable
fun FieldModeToggle(mode: FieldViewMode, onChange: (FieldViewMode) -> Unit) {
    Row(
        Modifier
            .clip(RoundedCornerShape(12.dp))
            .background(Color(0x6618181C))
            .padding(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text("View", color = Color.White)
        Spacer(Modifier.width(8.dp))
        SegmentedButton(
            options = listOf("Combined", "Per-component"),
            selectedIndex = if (mode == FieldViewMode.Combined) 0 else 1,
            onSelect = { onChange(if (it == 0) FieldViewMode.Combined else FieldViewMode.PerMagnet) }
        )
    }
}

@Composable
private fun SegmentedButton(
    options: List<String>,
    selectedIndex: Int,
    onSelect: (Int) -> Unit
) {
    Row(Modifier.clip(RoundedCornerShape(8.dp)).background(Color(0x331E1F26))) {
        options.forEachIndexed { idx, label ->
            val sel = idx == selectedIndex
            Box(
                Modifier
                    .background(if (sel) Color(0xFF2A2B33) else Color.Transparent)
                    .clickable { onSelect(idx) }
                    .padding(horizontal = 10.dp, vertical = 6.dp)
            ) {
                Text(label, color = Color.White, fontSize = 12.sp, fontWeight = if (sel) FontWeight.SemiBold else FontWeight.Normal)
            }
        }
    }
}

@Composable
fun MagneticLegend(magnets: List<Magnet>, mode: FieldViewMode) {
    if (mode != FieldViewMode.PerMagnet) return
    Row(
        Modifier
            .padding(8.dp)
            .clip(RoundedCornerShape(8.dp))
            .background(Color(0x6618181C))
            .padding(horizontal = 8.dp, vertical = 6.dp)
    ) {
        magnets.forEachIndexed { idx, m ->
            Row(Modifier.padding(end = 8.dp), verticalAlignment = Alignment.CenterVertically) {
                Box(
                    Modifier
                        .size(10.dp)
                        .clip(RoundedCornerShape(2.dp))
                        .background(magnetColors[idx % magnetColors.size])
                )
                Spacer(Modifier.width(4.dp))
                Text("#${m.id}", color = Color.White, fontSize = 11.sp)
            }
        }
    }
}

/** Draw vector field arrows + per-magnet σ rings. */
@Composable
fun MagneticFieldOverlay(
    magnets: List<Magnet>,
    show: Boolean,
    sizePx: IntSize,
    mode: FieldViewMode = FieldViewMode.Combined,
    cell: Int = 36,
    arrowLen: Float = 14f,
    ringSteps: Int = 3
) {
    if (!show) return
    Canvas(Modifier.fillMaxSize()) { // avoid BoxScope requirement
        fun drawArrow(from: Offset, dir: Offset, color: Color) {
            val d = dir.getDistance()
            if (d < 1e-3f) return
            val n = dir / d
            val to = from + n * arrowLen
            val base = color.copy(alpha = 0.33f)
            drawLine(base, from, to, strokeWidth = 1f)
            val left = to + (Offset(-n.y, n.x) * 3f) - n * 4f
            val right = to + (Offset(n.y, -n.x) * 3f) - n * 4f
            drawLine(base, to, left, strokeWidth = 1f)
            drawLine(base, to, right, strokeWidth = 1f)
        }

        // Arrows
        for (y in 0 until sizePx.height step cell) {
            for (x in 0 until sizePx.width step cell) {
                val p = Offset(x.toFloat(), y.toFloat())
                when (mode) {
                    FieldViewMode.Combined -> {
                        var gx = 0f; var gy = 0f
                        magnets.forEachIndexed { _, m ->
                            val dx = m.basePos.x - p.x; val dy = m.basePos.y - p.y
                            val d2 = dx * dx + dy * dy; val s2 = m.sigma * m.sigma
                            val phi = kotlin.math.exp(-d2 / (2f * s2))
                            gx += phi * (dx / s2); gy += phi * (dy / s2)
                        }
                        drawArrow(p, Offset(gx, gy), Color(0xFFA0C4FF))
                    }
                    FieldViewMode.PerMagnet -> {
                        magnets.forEachIndexed { idx, m ->
                            val dx = m.basePos.x - p.x; val dy = m.basePos.y - p.y
                            val d2 = dx * dx + dy * dy; val s2 = m.sigma * m.sigma
                            val phi = kotlin.math.exp(-d2 / (2f * s2))
                            val gx = phi * (dx / s2); val gy = phi * (dy / s2)
                            drawArrow(p, Offset(gx, gy), magnetColors[idx % magnetColors.size])
                        }
                    }
                }
            }
        }

        // σ rings (use base positions for clarity)
        magnets.forEachIndexed { idx, m ->
            repeat(ringSteps) { k ->
                val r = (k + 1) * (m.sigma / ringSteps)
                val col = if (mode == FieldViewMode.PerMagnet) magnetColors[idx % magnetColors.size] else Color(0xFFFFD479)
                drawCircle(
                    color = col.copy(alpha = if (k == ringSteps - 1) 0.5f else 0.2f),
                    radius = r, center = m.basePos,
                    style = Stroke(width = if (k == ringSteps - 1) 2f else 1f)
                )
            }
        }
    }
}

/* ──────────────────────────────────────────────────────────────────────────────
   DEMO: 3×3 grid with center press (σ shrink) → neighbors pull/repel
   ──────────────────────────────────────────────────────────────────────────── */

@Composable
fun MagneticGridDemo() {
    val density = LocalDensity.current
    val spacingPx = with(density) { 220.dp.toPx() }
    val cardSize = 160.dp

    // Build 3×3 magnets with base positions in px
    val magnets = remember {
        (0 until 9).map { idx ->
            val c = idx % 3; val r = idx / 3
            val base = Offset(c * spacingPx, r * spacingPx)
            val idle = 180f
            val pressed = 80f
            Magnet(
                id = idx,
                basePos = base,
                sigma = idle,
                sigmaIdle = idle,
                sigmaPressed = pressed
            )
        }
    }

    val centerId = 4
    val center = magnets[centerId]

    // Animatables for live positions (start at base)
    val anims = remember {
        magnets.associate { it.id to Animatable(it.basePos, Offset.VectorConverter) }
    }

    // Center press morphs σ; also scale for depth cue
    var pressed by remember { mutableStateOf(false) }
    val centerSigmaAnim = remember { Animatable(center.sigma) }
    LaunchedEffect(pressed) {
        val target = if (pressed) center.sigmaPressed else center.sigmaIdle
        centerSigmaAnim.animateTo(
            targetValue = target,
            animationSpec = tween(
                durationMillis = if (pressed) 140 else 160,
                easing = if (pressed) { x -> 1f - (1f - x).pow(3) } else { x -> x.pow(3) }
            )
        )
    }
    LaunchedEffect(centerSigmaAnim.value) { center.sigma = centerSigmaAnim.value }

    val pressScale by animateFloatAsState(if (pressed) 0.92f else 1f, label = "pressScale")

    // Debug overlay state
    var showFields by remember { mutableStateOf(false) }
    var mode by remember { mutableStateOf(FieldViewMode.Combined) }
    var canvasSize by remember { mutableStateOf(IntSize.Zero) }

    // Physics sim (uses live positions)
    val sim = remember { MagnetSim(count = magnets.size) }
    LaunchedEffect(Unit) {
        sim.initBaseline(
            basePositions = magnets.map { it.basePos },
            sigmas = magnets.map { it.sigmaIdle }
        )
    }

    LaunchedEffect(Unit) {
        while (isActive) {
            val positions = (0 until magnets.size).map { anims[it]!!.value }
            val sigmas = magnets.map { it.sigma }
            val forces = sim.step(
                positions = positions,
                sigmas = sigmas,
                anchoredIds = if (pressed) setOf(centerId) else emptySet()
            )
            // Retarget all to basePos + displacement from forces
            forces.forEach { (id, F) ->
                val base = magnets[id].basePos
                val target = base + (F * 0.006f) // gain controls pull strength
                anims[id]!!.animateTo(
                    target,
                    animationSpec = spring(dampingRatio = 0.98f, stiffness = 320f)
                )
            }
            withFrameNanos { }
        }
    }

    // UI
    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
        Box(
            Modifier
                .size(660.dp)
                .clip(RoundedCornerShape(24.dp))
                .background(Color(0xFF0F1116))
                .padding(24.dp)
                .onSizeChanged { canvasSize = it }
        ) {
            // 1) Overlay behind (so it never occludes cards)
            MagneticFieldOverlay(
                magnets = magnets,
                show = showFields,
                sizePx = canvasSize,
                mode = mode
            )

            // 2) Cards on top (use live anim values)
            magnets.forEach { m ->
                val pos by anims[m.id]!!.asState()
                val isCenter = m.id == centerId
                val scale = if (isCenter) pressScale else 1f
                Box(
                    Modifier
                        .offset { IntOffset(pos.x.toInt(), pos.y.toInt()) }
                        .size(cardSize)
                        .clip(RoundedCornerShape(24.dp))
                        .background(if (isCenter) Color(0xFF4C7EFF) else Color(0xFF1E1F26))
                        .graphicsLayer {
                            scaleX = scale
                            scaleY = scale
                        }
                        .pointerInput(Unit) {
                            if (isCenter) detectTapGestures(
                                onPress = {
                                    pressed = true
                                    tryAwaitRelease()
                                    pressed = false
                                }
                            )
                        }
                )
            }
        }

        // Controls
        Column(
            Modifier.align(Alignment.TopEnd).padding(8.dp),
            horizontalAlignment = Alignment.End
        ) {
            MagneticDebugToggle(show = showFields, onToggle = { showFields = it })
            Spacer(Modifier.height(8.dp))
            FieldModeToggle(mode = mode, onChange = { mode = it })
            MagneticLegend(magnets = magnets, mode = mode)
        }
    }
}